<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
    <link rel="shortcut icon" href="/images/avatar.png" type="image/x-icon" />
    <title>
        
            Crypto_Papers_Read_&amp;_Recurrent |
         
        Alexei
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    
<link rel="stylesheet" href="/fontawesome/css/fontawesome.min.css">

    
<link rel="stylesheet" href="/fontawesome/css/brands.min.css">

    
<link rel="stylesheet" href="/fontawesome/css/solid.min.css">

     
    
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-XXXXXXXXXXXX"></script>
        <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'G-XXXXXXXXXXXX');
        </script>
    


<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.0.0"><link rel="alternate" href="/atom.xml" title="Alexei" type="application/atom+xml">
</head>

<body>
    <div class="body-container">
        <div class="header-wrapper"><header>
    <div class="header-container">
        <div class="header-menu-list">
            <ul>
            
                <li>
                    <a href="/">Home</a>
                </li>
            
                <li>
                    <a href="/about">About</a>
                </li>
            
            </ul>
        </div>
    </div>
</header>
</div>
        <div class="main-wrapper"><main>
    <div class="main-container">
        <div class="post-details">
            
            <div class="post-title">
                <h1>Crypto_Papers_Read_&amp;_Recurrent</h1>
            </div>
            <div class="post-meta">
                <i class="fa-solid fa-clock"></i>&nbsp;<span class="post-date">2024/01/29</span>
            </div>
            
            <div class="post-content">
                <meta name="referrer" content="no-referrer"/>

<blockquote>
<p>碎碎念：本篇是我复现论文的集合。有很多翻译有疏漏，根本原因是我太菜了:( 。因此能用代码解释或者验证的地方，我都尽量写代码。</p>
<p>Talk is cheap, show me the code.</p>
</blockquote>
<h1 id="0x01-RSA私钥过大的漏洞"><a href="#0x01-RSA私钥过大的漏洞" class="headerlink" title="0x01  RSA私钥过大的漏洞"></a>0x01  RSA私钥过大的漏洞</h1><p><a target="_blank" rel="noopener" href="https://github.com/AL3XEI709/papers/blob/main/cacr2004-01.pdf">Link</a></p>
<blockquote>
<p>使用过小的RSA私钥指数引发的危险在十多年前就已经为人所知。用户虽然已知这些威胁，但依然希望从实质上降低解密时间，可能会倾向于使用一个与很大的私钥相关的<strong>小负素数</strong>。这篇论文展示了Wiener, Boneh &amp; Durfee, Blomer &amp; May的<strong>针对小私钥指数的攻击</strong>，以及由上述攻击延申的对含多个素数的RSA的攻击，<strong>同样适用于私钥指数非常大的情况</strong>。</p>
</blockquote>
<h2 id="1-1-低加密指数攻击"><a href="#1-1-低加密指数攻击" class="headerlink" title="1.1 低加密指数攻击"></a>1.1 低加密指数攻击</h2><p>考虑公钥指数$e&#x3D;3$ 的RSA。如果明文大小在 $0&lt;m&lt;N^{1&#x2F;3}$ 区间内，解密仅需简单的对密文 $c&#x3D;m^3\mod N$ 开三次方即可，因为 $m^3&lt;N$。考虑处于 $N-N^{1&#x2F;3}&lt;m&lt;N$ 区间内的明文。相应的，在有限域的表示里，$-N^{1&#x2F;3}&lt;m&lt;0$。令 $c&#x3D;m^3\mod N$ ，解密仅需计算出 $-c\mod N$ 的三次方，即 $m&#x3D;-^3\sqrt {-c}$​ 。</p>
<h2 id="1-2-连分数攻击-Wiener"><a href="#1-2-连分数攻击-Wiener" class="headerlink" title="1.2 连分数攻击( Wiener )"></a>1.2 连分数攻击( Wiener )</h2><p> 针对RSA小私钥指数的Wiener 攻击，可以轻而易举的扩展到针对大私钥指数的攻击。</p>
<p> <strong>定理1.</strong> 令RSA的模数为$N$，私钥指数$d$ 满足  $\sqrt 6 (\phi(N)-d)&lt;N^{1&#x2F;4}$ ，则公钥 $(N,e)$ 已知的情况下，在多项式时间 $\log_2N$ 内可以求得私钥。</p>
<p>由RSA公式：$ed\equiv 1\pmod {\phi(N)}$ ，可化为$e(d-\phi(N))\equiv1\pmod{\phi(N)}$ 。令 $D&#x3D;\phi(N)-d$，等式也可以写成<br>$$<br>eD&#x3D;-1+k\phi(N)<br>$$<br>$k$ 为正，且 $k&lt;D$。根据连分数的性质可求得</p>
<p><img src="https://gitee.com/alekseyp/picgo/raw/master/img/202401292106997.png" alt="image-20240129210633885"></p>
<p>因此，$k&#x2F;D$ 是 $e&#x2F;N$ 的一个连分数项。通过连分数算法我们可以计算所有$e&#x2F;N$ 连分数的子项，验证正确的 $k&#x2F;D$ 。令 $k’&#x2F;D’$ 是 $e&#x2F; N$ 连分数的子项，我们可以计算 $\phi’&#x3D;(eD’+1)&#x2F;k’$ 并尝试分解 $N$ 。当 $k’&#x2F;D’&#x3D;k&#x2F;D$ 时，$\phi’&#x3D;\phi(N)$，就能实现分解 $N$。$N$ 分解后，计算 $d&#x3D;e^{-1}\pmod {\phi(N)}$ ，自然地 $d&#x3D;\phi(N)-D$ 。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> getPrime, long_to_bytes <span class="keyword">as</span> ltb, bytes_to_long <span class="keyword">as</span> btl </span><br><span class="line">DEBUG = <span class="literal">True</span> </span><br><span class="line">flag = <span class="string">b&#x27;AL3XEI_FAKE_FLAG&#x27;</span> </span><br><span class="line"></span><br><span class="line">p,q = [getPrime(<span class="number">512</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="string">&quot;pq&quot;</span>] </span><br><span class="line">D = getPrime(<span class="number">250</span>) </span><br><span class="line">phi = ( p - <span class="number">1</span> ) * ( q - <span class="number">1</span> ) </span><br><span class="line">n = p * q </span><br><span class="line">d = phi - D </span><br><span class="line">e = <span class="built_in">int</span>(<span class="built_in">pow</span>(d, -<span class="number">1</span>, phi)) </span><br><span class="line">m = btl(flag) </span><br><span class="line">c = <span class="built_in">pow</span>( m, e, n ) </span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;n = <span class="subst">&#123; n &#125;</span>&quot;</span>) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;e = <span class="subst">&#123; e &#125;</span>&quot;</span>) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;c = <span class="subst">&#123; c &#125;</span>&quot;</span>) </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> DEBUG: </span><br><span class="line">    <span class="built_in">print</span>(D &lt; <span class="built_in">int</span>(( <span class="number">1</span> / <span class="number">3</span> ) * ( n ** ( <span class="number">1</span> / <span class="number">4</span>) ))) <span class="comment"># True</span></span><br><span class="line">    <span class="built_in">print</span>(d &gt; <span class="built_in">int</span>(( <span class="number">1</span> / <span class="number">3</span> ) * ( n ** ( <span class="number">1</span> / <span class="number">4</span>) ))) <span class="comment"># True</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> getPrime, long_to_bytes <span class="keyword">as</span> ltb, bytes_to_long <span class="keyword">as</span> btl </span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> invert, powmod</span><br><span class="line"></span><br><span class="line">n = </span><br><span class="line">e = </span><br><span class="line">c = </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> kD <span class="keyword">in</span> continued_fraction(e / n).convergents(): </span><br><span class="line">    k = kD.numer() </span><br><span class="line">    D = kD.denom() </span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">if</span> ( e * D + <span class="number">1</span>) % k == <span class="number">0</span>:</span><br><span class="line">            phi =  ( e * D + <span class="number">1</span>) // k </span><br><span class="line">            d = phi - D </span><br><span class="line">            <span class="keyword">if</span> (e * d) % phi == <span class="number">1</span>:</span><br><span class="line">                m = powmod(c, d, n) </span><br><span class="line">                <span class="keyword">if</span> ltb(m) == <span class="string">b&#x27;AL3XEI_FAKE_FLAG&#x27;</span>:</span><br><span class="line">                    <span class="built_in">print</span>(ltb(m))</span><br><span class="line">                    <span class="keyword">break</span> </span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        <span class="keyword">continue</span> </span><br><span class="line"><span class="comment"># b&#x27;AL3XEI_FAKE_FLAG&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="1-3-小逆元攻击-Boneh-Durfee"><a href="#1-3-小逆元攻击-Boneh-Durfee" class="headerlink" title="1.3 小逆元攻击( Boneh &amp; Durfee )"></a>1.3 小逆元攻击( Boneh &amp; Durfee )</h2><p>Boneh &amp; Durfee 提出的小私钥指数攻击是建立在解决小逆元问题上的。也即，给定整数 $A，M$ ，求较小的 $x, y$ 使得 $x_0(A+y_0)\equiv1\pmod M$ 成立。特别的，对于RSA，令 $e&#x3D;N^\alpha, a\approx 1,d&lt;N^\sigma$ ，且 $f(x,y)&#x3D;x(N+y)-1$ 。我们希望能找到 $x_0,y_0$ 满足<br>$$<br>f(x_0,y_0)\equiv0\pmod e, |x_0|&lt;X&#x3D;N^\sigma,|y_0|&lt;Y&#x3D;3N^{1&#x2F;2}<br>$$<br> 上述方程的一个解是 $(x_0,y_0)&#x3D;(k,\phi(N)-N)$ ，$k$ 是正整数，满足$ed-k\phi(N)&#x3D;1$ 。求得这个解就能恢复 $\phi(N)$，就能通过 $d&#x3D;e^{-1}\pmod{\phi(N)}$ 求得私钥指数。Boneh &amp; Durfee 攻击能够成立的界是 $d&lt;N^{0.292}$。</p>
<p><strong>定理2.</strong> 对针对RSA小私钥指数的，基于小逆元攻击的方法，如果在 $d&lt;N^\sigma$ 情况下成立，则在 $d&gt;\phi(N)-N^\sigma$ 情况下也成立。</p>
<p>由RSA公式：$ed\equiv 1\pmod {\phi(N)}$ ，可化为$e(d-\phi(N))\equiv1\pmod{\phi(N)}$ 。等式也可以写成<br>$$<br>e(d-\phi(N))&#x3D;1-k\phi(N)<br>$$<br>$k$ 是正整数。令 $\phi(N)&#x3D;N-s$ ，通过模 $e$ 化简上式得：<br>$$<br>k(N-s)\equiv1\pmod e<br>$$<br>就可以回到与 Boneh &amp; Durfee 相同的证明开端了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> getPrime, long_to_bytes <span class="keyword">as</span> ltb, bytes_to_long <span class="keyword">as</span> btl </span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> invert, powmod</span><br><span class="line"></span><br><span class="line">DEBUG = <span class="literal">True</span> </span><br><span class="line">flag = <span class="string">b&#x27;AL3XEI_FAKE_FLAG&#x27;</span> </span><br><span class="line"></span><br><span class="line">p,q = [getPrime(<span class="number">1024</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="string">&quot;pq&quot;</span>] </span><br><span class="line">D = getPrime(<span class="number">540</span>) </span><br><span class="line">phi = ( p - <span class="number">1</span> ) * ( q - <span class="number">1</span> ) </span><br><span class="line">n = p * q </span><br><span class="line">d = phi - D </span><br><span class="line">e = invert( e , phi ) </span><br><span class="line">m = btl(flag) </span><br><span class="line">c = powmod( m, e, n ) </span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;n = <span class="subst">&#123; n &#125;</span>&quot;</span>) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;e = <span class="subst">&#123; e &#125;</span>&quot;</span>) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;c = <span class="subst">&#123; c &#125;</span>&quot;</span>) </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> DEBUG: </span><br><span class="line">    <span class="built_in">print</span>(D &gt; <span class="built_in">int</span>(( <span class="number">1</span> / <span class="number">3</span> ) * ( n ** ( <span class="number">1</span> / <span class="number">4</span>) ))) <span class="comment"># True</span></span><br><span class="line">    <span class="built_in">print</span>(D &lt; <span class="built_in">int</span>(n ** <span class="number">0.292</span>)) <span class="comment"># True </span></span><br><span class="line">    <span class="built_in">print</span>(d &gt; <span class="built_in">int</span>(( <span class="number">1</span> / <span class="number">3</span> ) * ( n ** ( <span class="number">1</span> / <span class="number">4</span>) ))) <span class="comment"># True</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">small_roots</span>(<span class="params">f, bounds, m=<span class="number">1</span>, d=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> d:</span><br><span class="line">        d = f.degree()</span><br><span class="line"></span><br><span class="line">    R = f.base_ring()</span><br><span class="line">    N = R.cardinality()</span><br><span class="line"></span><br><span class="line">    f /= f.coefficients().pop(<span class="number">0</span>)</span><br><span class="line">    f = f.change_ring(ZZ)</span><br><span class="line"></span><br><span class="line">    G = <span class="type">Sequence</span>([], f.parent())</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m + <span class="number">1</span>):</span><br><span class="line">        base = N ^ (m - i) * f ^ i</span><br><span class="line">        <span class="keyword">for</span> shifts <span class="keyword">in</span> itertools.product(<span class="built_in">range</span>(d), repeat=f.nvariables()):</span><br><span class="line">            g = base * prod(<span class="built_in">map</span>(power, f.variables(), shifts))</span><br><span class="line">            G.append(g)</span><br><span class="line"></span><br><span class="line">    B, monomials = G.coefficient_matrix()</span><br><span class="line">    monomials = vector(monomials)</span><br><span class="line"></span><br><span class="line">    factors = [monomial(*bounds) <span class="keyword">for</span> monomial <span class="keyword">in</span> monomials]</span><br><span class="line">    <span class="keyword">for</span> i, factor <span class="keyword">in</span> <span class="built_in">enumerate</span>(factors):</span><br><span class="line">        B.rescale_col(i, factor)</span><br><span class="line"></span><br><span class="line">    B = B.dense_matrix().LLL()</span><br><span class="line"></span><br><span class="line">    B = B.change_ring(QQ)</span><br><span class="line">    <span class="keyword">for</span> i, factor <span class="keyword">in</span> <span class="built_in">enumerate</span>(factors):</span><br><span class="line">        B.rescale_col(i, <span class="number">1</span> / factor)</span><br><span class="line"></span><br><span class="line">    H = <span class="type">Sequence</span>([], f.parent().change_ring(QQ))</span><br><span class="line">    <span class="keyword">for</span> h <span class="keyword">in</span> <span class="built_in">filter</span>(<span class="literal">None</span>, B * monomials):</span><br><span class="line">        H.append(h)</span><br><span class="line">        I = H.ideal()</span><br><span class="line">        <span class="keyword">if</span> I.dimension() == -<span class="number">1</span>:</span><br><span class="line">            H.pop()</span><br><span class="line">        <span class="keyword">elif</span> I.dimension() == <span class="number">0</span>:</span><br><span class="line">            roots = []</span><br><span class="line">            <span class="keyword">for</span> root <span class="keyword">in</span> I.variety(ring=ZZ):</span><br><span class="line">                root = <span class="built_in">tuple</span>(R(root[var]) <span class="keyword">for</span> var <span class="keyword">in</span> f.variables())</span><br><span class="line">                roots.append(root)</span><br><span class="line">            <span class="keyword">return</span> roots</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">n = </span><br><span class="line">e = </span><br><span class="line">c = </span><br><span class="line">P = Zmod(ZZ(e))[<span class="string">&quot;k,s&quot;</span>]</span><br><span class="line">k, s = P.gens()</span><br><span class="line">f = <span class="number">1</span> + k * (n - s)</span><br><span class="line">rs = small_roots(f, (<span class="number">2</span>**<span class="number">540</span>, <span class="number">2</span>**<span class="number">1025</span>), m=<span class="number">4</span>, d=<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(rs)</span><br><span class="line">k, s = <span class="built_in">map</span>(<span class="built_in">int</span>, rs[<span class="number">0</span>])</span><br><span class="line">phi = n - s</span><br><span class="line">d = <span class="built_in">pow</span>(e, -<span class="number">1</span>, phi)</span><br><span class="line">m = <span class="built_in">pow</span>(c, d, n)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(<span class="built_in">int</span>(m)))</span><br></pre></td></tr></table></figure>



<h2 id="1-4-含多个素数的-RSA"><a href="#1-4-含多个素数的-RSA" class="headerlink" title="1.4 含多个素数的 RSA"></a>1.4 含多个素数的 RSA</h2><p>接下来的攻击将上述RSA攻击扩展到了含多个素数的形式。</p>
<p><strong>定理3.</strong> 令 $N$ 是含 $r$ 个素数（大小相近）的RSA，$d$ 为私钥指数，且满足 $\sqrt {2(2r-1)}|\phi(N)-d|&lt;N^{1&#x2F;(2r)}$。则公钥 $(N,e)$ 已知的情况下，在多项式时间  $N$ 内可以求得私钥。</p>
<p>证明过程与 Wiener 攻击近乎一致，不再阐述。</p>
<p><strong>定理4.</strong> 对针对含多个素数的RSA小私钥指数的，基于小逆元攻击的方法，如果在 $d&lt;N^\sigma$ 情况下成立，则在 $d&gt;\phi(N)-N^\sigma$ 情况下也成立。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> getPrime, bytes_to_long</span><br><span class="line"></span><br><span class="line">DEBUG = <span class="literal">True</span> </span><br><span class="line">p,q,r = [getPrime(<span class="number">1024</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="string">&quot;pqr&quot;</span>] </span><br><span class="line">n = p*q*r </span><br><span class="line">l = getPrime(<span class="number">500</span>)</span><br><span class="line">phi = (p - <span class="number">1</span>) * (q - <span class="number">1</span>) * (r - <span class="number">1</span>)</span><br><span class="line">d = phi - l </span><br><span class="line">e = <span class="built_in">int</span>(<span class="built_in">pow</span>(d, -<span class="number">1</span>, phi)) </span><br><span class="line"></span><br><span class="line">flag = <span class="string">b&#x27;flag&#123;AL3XEI_FAKE_FLAG&#125;&#x27;</span></span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line">c = <span class="built_in">pow</span>(m, e, n)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;n = &#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;e = &#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;c = &#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> DEBUG:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;down: &quot;</span>, <span class="built_in">int</span>((<span class="number">1</span>/<span class="number">3</span>)*(n**(<span class="number">1</span>/<span class="number">6</span>))).bit_length())  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;up: &quot;</span>, <span class="built_in">int</span>(<span class="built_in">pow</span>(n, <span class="number">0.292</span>)).bit_length())</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;k:&quot;</span>, <span class="built_in">int</span>((e*l+<span class="number">1</span>)//phi).bit_length()) </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;s:&quot;</span>, <span class="built_in">int</span>(-(- p*q-p*r-q*r+p+q+r-<span class="number">1</span>)).bit_length(), (e*l+<span class="number">1</span>)%phi)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">small_roots</span>(<span class="params">f, bounds, m=<span class="number">1</span>, d=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> d:</span><br><span class="line">        d = f.degree()</span><br><span class="line"></span><br><span class="line">    R = f.base_ring()</span><br><span class="line">    N = R.cardinality()</span><br><span class="line"></span><br><span class="line">    f /= f.coefficients().pop(<span class="number">0</span>)</span><br><span class="line">    f = f.change_ring(ZZ)</span><br><span class="line"></span><br><span class="line">    G = <span class="type">Sequence</span>([], f.parent())</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m + <span class="number">1</span>):</span><br><span class="line">        base = N ^ (m - i) * f ^ i</span><br><span class="line">        <span class="keyword">for</span> shifts <span class="keyword">in</span> itertools.product(<span class="built_in">range</span>(d), repeat=f.nvariables()):</span><br><span class="line">            g = base * prod(<span class="built_in">map</span>(power, f.variables(), shifts))</span><br><span class="line">            G.append(g)</span><br><span class="line"></span><br><span class="line">    B, monomials = G.coefficient_matrix()</span><br><span class="line">    monomials = vector(monomials)</span><br><span class="line"></span><br><span class="line">    factors = [monomial(*bounds) <span class="keyword">for</span> monomial <span class="keyword">in</span> monomials]</span><br><span class="line">    <span class="keyword">for</span> i, factor <span class="keyword">in</span> <span class="built_in">enumerate</span>(factors):</span><br><span class="line">        B.rescale_col(i, factor)</span><br><span class="line"></span><br><span class="line">    B = B.dense_matrix().LLL()</span><br><span class="line"></span><br><span class="line">    B = B.change_ring(QQ)</span><br><span class="line">    <span class="keyword">for</span> i, factor <span class="keyword">in</span> <span class="built_in">enumerate</span>(factors):</span><br><span class="line">        B.rescale_col(i, <span class="number">1</span> / factor)</span><br><span class="line"></span><br><span class="line">    H = <span class="type">Sequence</span>([], f.parent().change_ring(QQ))</span><br><span class="line">    <span class="keyword">for</span> h <span class="keyword">in</span> <span class="built_in">filter</span>(<span class="literal">None</span>, B * monomials):</span><br><span class="line">        H.append(h)</span><br><span class="line">        I = H.ideal()</span><br><span class="line">        <span class="keyword">if</span> I.dimension() == -<span class="number">1</span>:</span><br><span class="line">            H.pop()</span><br><span class="line">        <span class="keyword">elif</span> I.dimension() == <span class="number">0</span>:</span><br><span class="line">            roots = []</span><br><span class="line">            <span class="keyword">for</span> root <span class="keyword">in</span> I.variety(ring=ZZ):</span><br><span class="line">                root = <span class="built_in">tuple</span>(R(root[var]) <span class="keyword">for</span> var <span class="keyword">in</span> f.variables())</span><br><span class="line">                roots.append(root)</span><br><span class="line">            <span class="keyword">return</span> roots</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> []</span><br><span class="line">n = </span><br><span class="line">e = </span><br><span class="line">c = </span><br><span class="line"></span><br><span class="line">P = Zmod(ZZ(e))[<span class="string">&quot;k,s&quot;</span>]</span><br><span class="line">k, s = P.gens()</span><br><span class="line">f = <span class="number">1</span> + k * (n - s)</span><br><span class="line">rs = small_roots(f, (<span class="number">2</span>**<span class="number">500</span>, <span class="number">2</span>**<span class="number">2049</span>), m=<span class="number">4</span>, d=<span class="number">5</span> )</span><br><span class="line"><span class="built_in">print</span>(rs)</span><br><span class="line">k, s = <span class="built_in">map</span>(<span class="built_in">int</span>, rs[<span class="number">0</span>])</span><br><span class="line">phi = n - s</span><br><span class="line">d = <span class="built_in">pow</span>(e, -<span class="number">1</span>, phi)</span><br><span class="line">m = <span class="built_in">pow</span>(c, d, n)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(<span class="built_in">int</span>(m)))</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="1-5-总结"><a href="#1-5-总结" class="headerlink" title="1.5 总结"></a>1.5 总结</h2><p>RSA私钥指数过大会导致与私钥指数过小一样不安全。特别的，对于RSA，私钥指数 $|d|&lt;N^{1&#x2F;4}\sqrt 6$ 与 $|d|&lt; N^{0.292}$ 都会带来不安全性。</p>
<h1 id="0x02-二次生成器的密码分析"><a href="#0x02-二次生成器的密码分析" class="headerlink" title="0x02 二次生成器的密码分析"></a>0x02 二次生成器的密码分析</h1><p><a target="_blank" rel="noopener" href="https://github.com/AL3XEI709/papers/blob/main/Cryptanalysis_of_the_Quadratic_Generator.pdf">Link</a></p>
<blockquote>
<p>令 $p$ 为素数，$a,c$ 为模 $p$ 有限域内的整数。<strong>二次生成器</strong> (QCG) 是一个由等式关系 $v_{n+1}&#x3D;av_n^2+c\mod p$ 构成的伪随机数序列 $(v_n)$ 。这篇论文展示了如果任意多个连续的 $v_n$ 的<strong>高位已知</strong>，就可以在多项式时间内<strong>还原初始变量</strong> $v_0$ (即使在参数 $c$ 未知的情况下)，前提是初始变量 $v_0$ 不在某些特殊值的小的子集里。</p>
</blockquote>
<h2 id="2-1-二次生成器"><a href="#2-1-二次生成器" class="headerlink" title="2.1 二次生成器"></a>2.1 二次生成器</h2><p>令 $p$ 为素数，$a,c$ 为模 $p$ 有限域内的整数。<strong>二次生成器</strong> (QCG) 是一个由等式关系 $v_{n+1}&#x3D;av_n^2+c\mod p$ 构成的伪随机数序列 $(v_n)$ 。等式中的 $a, c$​ 分别被称为乘子和偏移量。</p>
<p>在密码设置中，初始量 $v_0$ 以及常量 $a, c$ 应该被设为私钥，利用生成器生成流密码。显然，如果多个连续的 $v_n$ 已知，求得 $v_0,a,c$ 是很容易的。所以在这个设置中，我们只输出 $v_n$ 的最高有效位 (msb) ，希望能让输出的序列更难预测。本篇论文讨论的就是在这种情况下如何预测 $v_{n+j}$ 。</p>
<p>假设序列 $(v_n)$ 未知，但对于给定的 $n$ ，一些近似值 $w_j$ 已知。以下分别讨论 $a,c$ 公开和 $a$ 公开，$c$ 不公开的两种情况下，如果 $w_j$ 条件足够好，$v_{n+j}$ 和 $a$ 就能在多项式内还原。</p>
<p>在开始前，还要定义一个参数 $\Delta$ ，用来衡量 $w_j$ 近似 $v_{n+j}$ 的程度。这个参数通常假设为 $\Delta &lt; p$ 。更确切地，$w$ 是 $u$ 的 $\Delta$ - 近似，等价于 $|w-u|&lt;\Delta$ 。</p>
<h2 id="2-2-乘子与偏移量已知，预测二次生成器"><a href="#2-2-乘子与偏移量已知，预测二次生成器" class="headerlink" title="2.2 乘子与偏移量已知，预测二次生成器"></a>2.2 乘子与偏移量已知，预测二次生成器</h2><p><strong>定理1.</strong> 令 $p$ 为素数，$\Delta$ 为 整数且 $p&gt;\Delta&gt;1$ 。对任意 $a, c\in F_p $ ，存在一个算法，当 $a,c$ 与二次生成器产生的两个连续的值 $v_0,v_1$  $\Delta$-近似的 $w_0,w_1$ 已知时，在多项式时间内返回 $v_0$ 的值。</p>
<p>令 $\varepsilon_j&#x3D;v_j-w_j,j&#x3D;0,1$ 。由 $v_1\equiv av_0^2+c\mod p$ ，可得<br>$$<br>w_1+\varepsilon_1-a(w_0+\varepsilon_0)^2-c\equiv0\mod p<br>$$<br>令<br>$$<br>A\equiv(w_1-aw_0^2-c)\mod p, \qquad B_1\equiv-2aw_0\Delta\mod p,\<br>B_2\equiv\Delta\mod p,\qquad C\equiv-a\Delta^2\mod p<br>$$<br>可得<br>$$<br>A\Delta^2+B_1\Delta\varepsilon_0+B_2\Delta\varepsilon_1+C\varepsilon_0^2\equiv0\mod p<br>$$<br>因此由同余式<br>$$<br>Ax_0+B_1x_1+B_2x_2+Cx_3\equiv0\mod p,\<br>x_0\equiv0\mod \Delta^2,\<br>x_1\equiv x_2\equiv0\mod \Delta<br>$$<br>构成的格 $L$ 含有解  $x&#x3D;(x_0,x_1,x_2,x_3)\in ZZ^4$ 。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint </span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> * </span><br><span class="line"></span><br><span class="line">Bits = <span class="number">512</span></span><br><span class="line">UnKnownBits = <span class="number">146</span> </span><br><span class="line">flag = <span class="string">b&#x27;flag&#123;AL3XEI_FAKE_FLAG&#125;&#x27;</span> </span><br><span class="line"></span><br><span class="line">p = getPrime(Bits) </span><br><span class="line">a, c = [randint(<span class="number">0</span>, p) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="string">&quot;ac&quot;</span>] </span><br><span class="line"></span><br><span class="line">v_0 = bytes_to_long(flag) </span><br><span class="line">v_1 = (a*v_0**<span class="number">2</span>+c)%p </span><br><span class="line">v_2 = (a*v_1**<span class="number">2</span>+c)%p  </span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;a = <span class="subst">&#123;a&#125;</span>&quot;</span>) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;c = <span class="subst">&#123;c&#125;</span>&quot;</span>) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;p = <span class="subst">&#123;p&#125;</span>&quot;</span>) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;high_v1 = <span class="subst">&#123;v_1&gt;&gt;UnKnownBits&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;high_v2 = <span class="subst">&#123;v_2&gt;&gt;UnKnownBits&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">small_roots</span>(<span class="params">f, bounds, m=<span class="number">1</span>, d=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> d:</span><br><span class="line">        d = f.degree()</span><br><span class="line"></span><br><span class="line">    R = f.base_ring()</span><br><span class="line">    N = R.cardinality()</span><br><span class="line"></span><br><span class="line">    f /= f.coefficients().pop(<span class="number">0</span>)</span><br><span class="line">    f = f.change_ring(ZZ)</span><br><span class="line"></span><br><span class="line">    G = <span class="type">Sequence</span>([], f.parent())</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m + <span class="number">1</span>):</span><br><span class="line">        base = N ^ (m - i) * f ^ i</span><br><span class="line">        <span class="keyword">for</span> shifts <span class="keyword">in</span> itertools.product(<span class="built_in">range</span>(d), repeat=f.nvariables()):</span><br><span class="line">            g = base * prod(<span class="built_in">map</span>(power, f.variables(), shifts))</span><br><span class="line">            G.append(g)</span><br><span class="line"></span><br><span class="line">    B, monomials = G.coefficient_matrix()</span><br><span class="line">    monomials = vector(monomials)</span><br><span class="line"></span><br><span class="line">    factors = [monomial(*bounds) <span class="keyword">for</span> monomial <span class="keyword">in</span> monomials]</span><br><span class="line">    <span class="keyword">for</span> i, factor <span class="keyword">in</span> <span class="built_in">enumerate</span>(factors):</span><br><span class="line">        B.rescale_col(i, factor)</span><br><span class="line"></span><br><span class="line">    B = B.dense_matrix().LLL()</span><br><span class="line"></span><br><span class="line">    B = B.change_ring(QQ)</span><br><span class="line">    <span class="keyword">for</span> i, factor <span class="keyword">in</span> <span class="built_in">enumerate</span>(factors):</span><br><span class="line">        B.rescale_col(i, <span class="number">1</span> / factor)</span><br><span class="line"></span><br><span class="line">    H = <span class="type">Sequence</span>([], f.parent().change_ring(QQ))</span><br><span class="line">    <span class="keyword">for</span> h <span class="keyword">in</span> <span class="built_in">filter</span>(<span class="literal">None</span>, B * monomials):</span><br><span class="line">        H.append(h)</span><br><span class="line">        I = H.ideal()</span><br><span class="line">        <span class="keyword">if</span> I.dimension() == -<span class="number">1</span>:</span><br><span class="line">            H.pop()</span><br><span class="line">        <span class="keyword">elif</span> I.dimension() == <span class="number">0</span>:</span><br><span class="line">            roots = []</span><br><span class="line">            <span class="keyword">for</span> root <span class="keyword">in</span> I.variety(ring=ZZ):</span><br><span class="line">                root = <span class="built_in">tuple</span>(R(root[var]) <span class="keyword">for</span> var <span class="keyword">in</span> f.variables())</span><br><span class="line">                roots.append(root)</span><br><span class="line">            <span class="keyword">return</span> roots</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> []</span><br><span class="line">a = </span><br><span class="line">c = </span><br><span class="line">p = </span><br><span class="line">high_v1 = </span><br><span class="line">high_v2 = </span><br><span class="line">PR = Zmod(ZZ(p))[<span class="string">&quot;l1, l2&quot;</span>] </span><br><span class="line">l1, l2 = PR.gens() </span><br><span class="line">f = a*(high_v1*(<span class="number">2</span>^<span class="number">146</span>)+l1)^<span class="number">2</span>+c-(high_v2*(<span class="number">2</span>^<span class="number">146</span>)+l2)</span><br><span class="line">low_v1 = ZZ(small_roots(f, (<span class="number">2</span>^<span class="number">146</span>, <span class="number">2</span>^<span class="number">146</span>), m=<span class="number">3</span>, d=<span class="number">4</span>)[<span class="number">0</span>][<span class="number">0</span>]) </span><br><span class="line"></span><br><span class="line">v_0 = mod(((high_v1*(<span class="number">2</span>^<span class="number">146</span>)+low_v1)-c)*inverse_mod(a, p)%p, p).sqrt() </span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(ZZ(v_0)))</span><br></pre></td></tr></table></figure>



<h2 id="2-3-乘子已知，偏移量未知，预测二次生成器"><a href="#2-3-乘子已知，偏移量未知，预测二次生成器" class="headerlink" title="2.3 乘子已知，偏移量未知，预测二次生成器"></a>2.3 乘子已知，偏移量未知，预测二次生成器</h2><p><strong>定理2.</strong> 令 $p$ 为素数，$\Delta$ 为 整数且 $p&gt;\Delta&gt;1$ 。对任意 $a, c\in F_p $ ，存在一个算法，当 $a$ 与二次生成器产生的三个连续的值 $v_0,v_1,v_2$  $\Delta$-近似的 $w_0,w_1,w_2$ 已知时，在多项式时间内返回 $v_0$​ 的值。</p>
<p>令 $v_i&#x3D;w_i+\varepsilon_i,|\varepsilon_i|&lt;\Delta,i&#x3D;0,1,2$ ，且 $av_i^2+c&#x3D;v_{i+1}\mod p,i&#x3D;0,1$ ，可得含已知量 $a,w_i$ 和未知量 $\varepsilon_i$ 的方程：<br>$$<br>(aw_0^2-w_1-aw_1^2+w_2)+2aw_0\varepsilon_0-\<br>(1+2aw_1)\varepsilon_1+\varepsilon_2+a(\varepsilon_0^2-\varepsilon_1^2)\equiv 0\mod p<br>$$<br>向量 $(1,\varepsilon_0,\varepsilon_1,\varepsilon_2,\varepsilon_0^2-\varepsilon1^2 )$ 满足已知的一致性系数。为了使量标更平衡，将上式写作：<br>$$<br>(aw_0^2-w_1-aw_1^2+w_2)\Delta^2+2aw_0\Delta\Delta\varepsilon_0-(1+2aw_1)\Delta\Delta\varepsilon_1+\<br>+\Delta\Delta\varepsilon_2+a\Delta^2(\varepsilon_0^2-\varepsilon_1^2)\equiv0\mod p<br>$$<br>因此由同余式<br>$$<br>(aw_0^2-w_1-aw_1^2+w_2)x_0+2aw_0\Delta x_1-(1+2aw_1)\Delta x_2+\<br>+\Delta x_3+a\Delta^2 x_4\equiv0\mod p,\<br>x_0\equiv0\pmod \Delta^2,\<br>x_1,x_2,x_3\equiv0\mod \Delta<br>$$<br>构成的格 $L$ 含有解 $e&#x3D;(\Delta^2,\Delta\varepsilon_0,\Delta\varepsilon_1,\Delta\varepsilon_2,\varepsilon_0^2-\varepsilon_1^2)\in ZZ^5$ 。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint </span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> * </span><br><span class="line"></span><br><span class="line">Bits = <span class="number">256</span></span><br><span class="line">UnKnownBits = <span class="number">48</span></span><br><span class="line">flag = <span class="string">b&#x27;flag&#123;AL3XEI_FAKE_FLAG&#125;&#x27;</span> </span><br><span class="line"></span><br><span class="line">p = getPrime(Bits) </span><br><span class="line">a, c = [randint(<span class="number">0</span>, p) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="string">&quot;ac&quot;</span>] </span><br><span class="line">v_0 = bytes_to_long(flag) </span><br><span class="line"><span class="keyword">assert</span> v_0&lt;p</span><br><span class="line">v_1 = (a*v_0**<span class="number">2</span>+c)%p </span><br><span class="line">v_2 = (a*v_1**<span class="number">2</span>+c)%p  </span><br><span class="line">v_3 = (a*v_2**<span class="number">2</span>+c)%p  </span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;a = <span class="subst">&#123;a&#125;</span>&quot;</span>) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;p = <span class="subst">&#123;p&#125;</span>&quot;</span>) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;high_v0 = <span class="subst">&#123;v_1&gt;&gt;UnKnownBits&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;high_v1 = <span class="subst">&#123;v_2&gt;&gt;UnKnownBits&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;high_v2 = <span class="subst">&#123;v_3&gt;&gt;UnKnownBits&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">small_roots</span>(<span class="params">f, bounds, m=<span class="number">1</span>, d=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> d:</span><br><span class="line">        d = f.degree()</span><br><span class="line"></span><br><span class="line">    R = f.base_ring()</span><br><span class="line">    N = R.cardinality()</span><br><span class="line"></span><br><span class="line">    f /= f.coefficients().pop(<span class="number">0</span>)</span><br><span class="line">    f = f.change_ring(ZZ)</span><br><span class="line"></span><br><span class="line">    G = <span class="type">Sequence</span>([], f.parent())</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m + <span class="number">1</span>):</span><br><span class="line">        base = N ^ (m - i) * f ^ i</span><br><span class="line">        <span class="keyword">for</span> shifts <span class="keyword">in</span> itertools.product(<span class="built_in">range</span>(d), repeat=f.nvariables()):</span><br><span class="line">            g = base * prod(<span class="built_in">map</span>(power, f.variables(), shifts))</span><br><span class="line">            G.append(g)</span><br><span class="line"></span><br><span class="line">    B, monomials = G.coefficient_matrix()</span><br><span class="line">    monomials = vector(monomials)</span><br><span class="line"></span><br><span class="line">    factors = [monomial(*bounds) <span class="keyword">for</span> monomial <span class="keyword">in</span> monomials]</span><br><span class="line">    <span class="keyword">for</span> i, factor <span class="keyword">in</span> <span class="built_in">enumerate</span>(factors):</span><br><span class="line">        B.rescale_col(i, factor)</span><br><span class="line"></span><br><span class="line">    B = B.dense_matrix().LLL()</span><br><span class="line"></span><br><span class="line">    B = B.change_ring(QQ)</span><br><span class="line">    <span class="keyword">for</span> i, factor <span class="keyword">in</span> <span class="built_in">enumerate</span>(factors):</span><br><span class="line">        B.rescale_col(i, <span class="number">1</span> / factor)</span><br><span class="line"></span><br><span class="line">    H = <span class="type">Sequence</span>([], f.parent().change_ring(QQ))</span><br><span class="line">    <span class="keyword">for</span> h <span class="keyword">in</span> <span class="built_in">filter</span>(<span class="literal">None</span>, B * monomials):</span><br><span class="line">        H.append(h)</span><br><span class="line">        I = H.ideal()</span><br><span class="line">        <span class="keyword">if</span> I.dimension() == -<span class="number">1</span>:</span><br><span class="line">            H.pop()</span><br><span class="line">        <span class="keyword">elif</span> I.dimension() == <span class="number">0</span>:</span><br><span class="line">            roots = []</span><br><span class="line">            <span class="keyword">for</span> root <span class="keyword">in</span> I.variety(ring=ZZ):</span><br><span class="line">                root = <span class="built_in">tuple</span>(R(root[var]) <span class="keyword">for</span> var <span class="keyword">in</span> f.variables())</span><br><span class="line">                roots.append(root)</span><br><span class="line">            <span class="keyword">return</span> roots</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">UnKnownBits = <span class="number">48</span></span><br><span class="line">a = </span><br><span class="line">p = </span><br><span class="line">high_v0 = </span><br><span class="line">high_v1 = </span><br><span class="line">high_v2 = </span><br><span class="line"></span><br><span class="line">high_v0 = high_v0&lt;&lt;UnKnownBits</span><br><span class="line">high_v1 = high_v1&lt;&lt;UnKnownBits</span><br><span class="line">high_v2 = high_v2&lt;&lt;UnKnownBits</span><br><span class="line"></span><br><span class="line">PR = Zmod(ZZ(p))[<span class="string">&quot;l0, l1, l2&quot;</span>] </span><br><span class="line">l0, l1, l2 = PR.gens() </span><br><span class="line">f =( a*high_v0^<span class="number">2</span>-high_v1-a*high_v1^<span class="number">2</span>+high_v2 ) + <span class="number">2</span>*a*high_v0*l0 - (<span class="number">1</span>+<span class="number">2</span>*a*high_v1)*l1 + l2 + a*(l0^<span class="number">2</span>-l1^<span class="number">2</span>) </span><br><span class="line"></span><br><span class="line">ls = small_roots(f, (<span class="number">2</span>^UnKnownBits, <span class="number">2</span>^UnKnownBits, <span class="number">2</span>^UnKnownBits), m=<span class="number">3</span>, d=<span class="number">4</span>)</span><br><span class="line">v_0, v_1, v_2 = high_v0+ZZ(ls[<span class="number">0</span>][<span class="number">0</span>]), high_v1+ZZ(ls[<span class="number">0</span>][<span class="number">1</span>]), high_v2+ZZ(ls[<span class="number">0</span>][<span class="number">2</span>]) </span><br><span class="line">c = (v_1 - a*v_0^<span class="number">2</span>) </span><br><span class="line"></span><br><span class="line">sd = mod((v_0-c)*inverse_mod(a, p)%p, p).sqrt() </span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(ZZ(sd)))</span><br></pre></td></tr></table></figure>



<h2 id="2-4-总结-尚未解决的问题"><a href="#2-4-总结-尚未解决的问题" class="headerlink" title="2.4 总结&amp;尚未解决的问题"></a>2.4 总结&amp;尚未解决的问题</h2><p>显然定理1的界 $\Delta&#x3D;O(p^{1&#x2F;4})$ ，定理2的界 $\Delta&#x3D;O(p^{1&#x2F;5})$ 。因此是否能提高 $\Delta$​ 的界值得讨论。</p>
<p>在 $c$ 给出但乘子 $a$ 未知的条件下也能用类似的过程预测二次生成器。</p>
<p>目前还不清楚当模数 $p$ 未知时如何预测二次生成器。</p>
<h1 id="0x03-在攻击变体-RSA-中找到具有新应用的多元多项式根的策略"><a href="#0x03-在攻击变体-RSA-中找到具有新应用的多元多项式根的策略" class="headerlink" title="0x03 在攻击变体 RSA 中找到具有新应用的多元多项式根的策略"></a>0x03 在攻击变体 RSA 中找到具有新应用的多元多项式根的策略</h1><p><a target="_blank" rel="noopener" href="https://github.com/AL3XEI709/papers/blob/main/jochemszmay.pdf">Link</a></p>

            </div>
        </div>
    </div>
</main>

<script src="https://utteranc.es/client.js"
    repo="AL3XEI709/AL3XEI709.github.io.git"
    issue-term="pathname"
    theme="github-light"
    crossorigin="anonymous"
    async>
</script>


    <script>
    MathJax = {
        tex: {
            inlineMath: [['$', '$'], ['\\(', '\\)']]
        }
    };
</script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.min.js"></script>
  

</div>
        <div class="footer-wrapper"><footer>
    <div class="footer-container">
        <div class="footer-meta">
            
                <div class="footer-meta-copyright">
                    &copy; 2024 Al3XEI709.
                </div>
            
            
                <div class="footer-meta-licenese">
                    Licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC-BY-NC-SA 4.0</a>
                </div>
            
            
                <div class="footer-meta-rss">
                    <a href="/atom.xml"><i class="fa-solid fa-rss"></i></a>
                </div>
            
        </div>
    </div>
</footer>
</div>
    </div>
</body>
</html>
