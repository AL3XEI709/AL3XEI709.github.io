<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
    <link rel="shortcut icon" href="/images/avatar.png" type="image/x-icon" />
    <title>
        
            Crypto_Papers_Read_&amp;_Recurrent |
         
        Alexei
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    
<link rel="stylesheet" href="/fontawesome/css/fontawesome.min.css">

    
<link rel="stylesheet" href="/fontawesome/css/brands.min.css">

    
<link rel="stylesheet" href="/fontawesome/css/solid.min.css">

     
    
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-XXXXXXXXXXXX"></script>
        <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'G-XXXXXXXXXXXX');
        </script>
    


<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.0.0"><link rel="alternate" href="/atom.xml" title="Alexei" type="application/atom+xml">
</head>

<body>
    <div class="body-container">
        <div class="header-wrapper"><header>
    <div class="header-container">
        <div class="header-menu-list">
            <ul>
            
                <li>
                    <a href="/">Home</a>
                </li>
            
                <li>
                    <a href="/about">About</a>
                </li>
            
            </ul>
        </div>
    </div>
</header>
</div>
        <div class="main-wrapper"><main>
    <div class="main-container">
        <div class="post-details">
            
            <div class="post-title">
                <h1>Crypto_Papers_Read_&amp;_Recurrent</h1>
            </div>
            <div class="post-meta">
                <i class="fa-solid fa-clock"></i>&nbsp;<span class="post-date">2024/01/29</span>
            </div>
            
            <div class="post-content">
                <meta name="referrer" content="no-referrer"/>



<p>[TOC]</p>
<h1 id="0x01-RSA私钥过大的漏洞"><a href="#0x01-RSA私钥过大的漏洞" class="headerlink" title="0x01  RSA私钥过大的漏洞"></a>0x01  RSA私钥过大的漏洞</h1><p><a target="_blank" rel="noopener" href="https://github.com/AL3XEI709/papers/blob/main/cacr2004-01.pdf">Link</a></p>
<blockquote>
<p>使用过小的RSA私钥指数引发的危险在十多年前就已经为人所知。用户虽然已知这些威胁，但依然希望从实质上降低解密时间，可能会倾向于使用一个与很大的私钥相关的<strong>小负素数</strong>。这篇论文展示了Wiener, Boneh &amp; Durfee, Blomer &amp; May的<strong>针对小私钥指数的攻击</strong>，以及由上述攻击延申的对含多个素数的RSA的攻击，<strong>同样适用于私钥指数非常大的情况</strong>。</p>
</blockquote>
<h2 id="1-1-低加密指数攻击"><a href="#1-1-低加密指数攻击" class="headerlink" title="1.1 低加密指数攻击"></a>1.1 低加密指数攻击</h2><p>考虑公钥指数$e&#x3D;3$ 的RSA。如果明文大小在 $0&lt;m&lt;N^{1&#x2F;3}$ 区间内，解密仅需简单的对密文 $c&#x3D;m^3\mod N$ 开三次方即可，因为 $m^3&lt;N$。考虑处于 $N-N^{1&#x2F;3}&lt;m&lt;N$ 区间内的明文。相应的，在有限域的表示里，$-N^{1&#x2F;3}&lt;m&lt;0$。令 $c&#x3D;m^3\mod N$ ，解密仅需计算出 $-c\mod N$ 的三次方，即 $m&#x3D;-^3\sqrt {-c}$​ 。</p>
<h2 id="1-2-连分数攻击-Wiener"><a href="#1-2-连分数攻击-Wiener" class="headerlink" title="1.2 连分数攻击( Wiener )"></a>1.2 连分数攻击( Wiener )</h2><p> 针对RSA小私钥指数的Wiener 攻击，可以轻而易举的扩展到针对大私钥指数的攻击。</p>
<p> <strong>定理1.</strong> 令RSA的模数为$N$，私钥指数$d$ 满足  $\sqrt 6 (\phi(N)-d)&lt;N^{1&#x2F;4}$ ，则公钥 $(N,e)$ 已知的情况下，在多项式时间 $\log_2N$ 内可以求得私钥。</p>
<p>由RSA公式：$ed\equiv 1\pmod {\phi(N)}$ ，可化为$e(d-\phi(N))\equiv1\pmod{\phi(N)}$ 。令 $D&#x3D;\phi(N)-d$，等式也可以写成<br>$$<br>eD&#x3D;-1+k\phi(N)<br>$$<br>$k$ 为正，且 $k&lt;D$。根据连分数的性质可求得</p>
<p><img src="https://gitee.com/alekseyp/picgo/raw/master/img/202401292106997.png" alt="image-20240129210633885"></p>
<p>因此，$k&#x2F;D$ 是 $e&#x2F;N$ 的一个连分数项。通过连分数算法我们可以计算所有$e&#x2F;N$ 连分数的子项，验证正确的 $k&#x2F;D$ 。令 $k’&#x2F;D’$ 是 $e&#x2F; N$ 连分数的子项，我们可以计算 $\phi’&#x3D;(eD’+1)&#x2F;k’$ 并尝试分解 $N$ 。当 $k’&#x2F;D’&#x3D;k&#x2F;D$ 时，$\phi’&#x3D;\phi(N)$，就能实现分解 $N$。$N$ 分解后，计算 $d&#x3D;e^{-1}\pmod {\phi(N)}$ ，自然地 $d&#x3D;\phi(N)-D$ 。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> getPrime, long_to_bytes <span class="keyword">as</span> ltb, bytes_to_long <span class="keyword">as</span> btl </span><br><span class="line">DEBUG = <span class="literal">True</span> </span><br><span class="line">flag = <span class="string">b&#x27;AL3XEI_FAKE_FLAG&#x27;</span> </span><br><span class="line"></span><br><span class="line">p,q = [getPrime(<span class="number">512</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="string">&quot;pq&quot;</span>] </span><br><span class="line">D = getPrime(<span class="number">250</span>) </span><br><span class="line">phi = ( p - <span class="number">1</span> ) * ( q - <span class="number">1</span> ) </span><br><span class="line">n = p * q </span><br><span class="line">d = phi - D </span><br><span class="line">e = <span class="built_in">int</span>(<span class="built_in">pow</span>(d, -<span class="number">1</span>, phi)) </span><br><span class="line">m = btl(flag) </span><br><span class="line">c = <span class="built_in">pow</span>( m, e, n ) </span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;n = <span class="subst">&#123; n &#125;</span>&quot;</span>) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;e = <span class="subst">&#123; e &#125;</span>&quot;</span>) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;c = <span class="subst">&#123; c &#125;</span>&quot;</span>) </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> DEBUG: </span><br><span class="line">    <span class="built_in">print</span>(D &lt; <span class="built_in">int</span>(( <span class="number">1</span> / <span class="number">3</span> ) * ( n ** ( <span class="number">1</span> / <span class="number">4</span>) ))) <span class="comment"># True</span></span><br><span class="line">    <span class="built_in">print</span>(d &gt; <span class="built_in">int</span>(( <span class="number">1</span> / <span class="number">3</span> ) * ( n ** ( <span class="number">1</span> / <span class="number">4</span>) ))) <span class="comment"># True</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> getPrime, long_to_bytes <span class="keyword">as</span> ltb, bytes_to_long <span class="keyword">as</span> btl </span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> invert, powmod</span><br><span class="line"></span><br><span class="line">n = </span><br><span class="line">e = </span><br><span class="line">c = </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> kD <span class="keyword">in</span> continued_fraction(e / n).convergents(): </span><br><span class="line">    k = kD.numer() </span><br><span class="line">    D = kD.denom() </span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">if</span> ( e * D + <span class="number">1</span>) % k == <span class="number">0</span>:</span><br><span class="line">            phi =  ( e * D + <span class="number">1</span>) // k </span><br><span class="line">            d = phi - D </span><br><span class="line">            <span class="keyword">if</span> (e * d) % phi == <span class="number">1</span>:</span><br><span class="line">                m = powmod(c, d, n) </span><br><span class="line">                <span class="keyword">if</span> ltb(m) == <span class="string">b&#x27;AL3XEI_FAKE_FLAG&#x27;</span>:</span><br><span class="line">                    <span class="built_in">print</span>(ltb(m))</span><br><span class="line">                    <span class="keyword">break</span> </span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        <span class="keyword">continue</span> </span><br><span class="line"><span class="comment"># b&#x27;AL3XEI_FAKE_FLAG&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="1-3-小逆元攻击-Boneh-Durfee"><a href="#1-3-小逆元攻击-Boneh-Durfee" class="headerlink" title="1.3 小逆元攻击( Boneh &amp; Durfee )"></a>1.3 小逆元攻击( Boneh &amp; Durfee )</h2><p>Boneh &amp; Durfee 提出的小私钥指数攻击是建立在解决小逆元问题上的。也即，给定整数 $A，M$ ，求较小的 $x, y$ 使得 $x_0(A+y_0)\equiv1\pmod M$ 成立。特别的，对于RSA，令 $e&#x3D;N^\alpha, a\approx 1,d&lt;N^\sigma$ ，且 $f(x,y)&#x3D;x(N+y)-1$ 。我们希望能找到 $x_0,y_0$ 满足<br>$$<br>f(x_0,y_0)\equiv0\pmod e, |x_0|&lt;X&#x3D;N^\sigma,|y_0|&lt;Y&#x3D;3N^{1&#x2F;2}<br>$$<br> 上述方程的一个解是 $(x_0,y_0)&#x3D;(k,\phi(N)-N)$ ，$k$ 是正整数，满足$ed-k\phi(N)&#x3D;1$ 。求得这个解就能恢复 $\phi(N)$，就能通过 $d&#x3D;e^{-1}\pmod{\phi(N)}$ 求得私钥指数。Boneh &amp; Durfee 攻击能够成立的界是 $d&lt;N^{0.292}$。</p>
<p><strong>定理2.</strong> 对针对RSA小私钥指数的，基于小逆元攻击的方法，如果在 $d&lt;N^\sigma$ 情况下成立，则在 $d&gt;\phi(N)-N^\sigma$ 情况下也成立。</p>
<p>由RSA公式：$ed\equiv 1\pmod {\phi(N)}$ ，可化为$e(d-\phi(N))\equiv1\pmod{\phi(N)}$ 。等式也可以写成<br>$$<br>e(d-\phi(N))&#x3D;1-k\phi(N)<br>$$<br>$k$ 是正整数。令 $\phi(N)&#x3D;N-s$ ，通过模 $e$ 化简上式得：<br>$$<br>k(N-s)\equiv1\pmod e<br>$$<br>就可以回到与 Boneh &amp; Durfee 相同的证明开端了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> getPrime, long_to_bytes <span class="keyword">as</span> ltb, bytes_to_long <span class="keyword">as</span> btl </span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> invert, powmod</span><br><span class="line"></span><br><span class="line">DEBUG = <span class="literal">True</span> </span><br><span class="line">flag = <span class="string">b&#x27;flag&#123;AL3XEI_FAKE_FLAG&#125;&#x27;</span> </span><br><span class="line"></span><br><span class="line">p,q = [getPrime(<span class="number">1024</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="string">&quot;pq&quot;</span>] </span><br><span class="line">D = getPrime(<span class="number">540</span>) </span><br><span class="line">phi = ( p - <span class="number">1</span> ) * ( q - <span class="number">1</span> ) </span><br><span class="line">n = p * q </span><br><span class="line">d = phi - D </span><br><span class="line">e = invert( d , phi ) </span><br><span class="line">m = btl(flag) </span><br><span class="line">c = powmod( m, e, n ) </span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;n = <span class="subst">&#123; n &#125;</span>&quot;</span>) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;e = <span class="subst">&#123; e &#125;</span>&quot;</span>) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;c = <span class="subst">&#123; c &#125;</span>&quot;</span>) </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> DEBUG: </span><br><span class="line">    <span class="built_in">print</span>(D &gt; <span class="built_in">int</span>(( <span class="number">1</span> / <span class="number">3</span> ) * ( n ** ( <span class="number">1</span> / <span class="number">4</span>) ))) <span class="comment"># True</span></span><br><span class="line">    <span class="built_in">print</span>(D &lt; <span class="built_in">int</span>(n ** <span class="number">0.292</span>)) <span class="comment"># True </span></span><br><span class="line">    <span class="built_in">print</span>(d &gt; <span class="built_in">int</span>(( <span class="number">1</span> / <span class="number">3</span> ) * ( n ** ( <span class="number">1</span> / <span class="number">4</span>) ))) <span class="comment"># True</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">small_roots</span>(<span class="params">f, bounds, m=<span class="number">1</span>, d=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> d:</span><br><span class="line">        d = f.degree()</span><br><span class="line"></span><br><span class="line">    R = f.base_ring()</span><br><span class="line">    N = R.cardinality()</span><br><span class="line"></span><br><span class="line">    f /= f.coefficients().pop(<span class="number">0</span>)</span><br><span class="line">    f = f.change_ring(ZZ)</span><br><span class="line"></span><br><span class="line">    G = <span class="type">Sequence</span>([], f.parent())</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m + <span class="number">1</span>):</span><br><span class="line">        base = N ^ (m - i) * f ^ i</span><br><span class="line">        <span class="keyword">for</span> shifts <span class="keyword">in</span> itertools.product(<span class="built_in">range</span>(d), repeat=f.nvariables()):</span><br><span class="line">            g = base * prod(<span class="built_in">map</span>(power, f.variables(), shifts))</span><br><span class="line">            G.append(g)</span><br><span class="line"></span><br><span class="line">    B, monomials = G.coefficient_matrix()</span><br><span class="line">    monomials = vector(monomials)</span><br><span class="line"></span><br><span class="line">    factors = [monomial(*bounds) <span class="keyword">for</span> monomial <span class="keyword">in</span> monomials]</span><br><span class="line">    <span class="keyword">for</span> i, factor <span class="keyword">in</span> <span class="built_in">enumerate</span>(factors):</span><br><span class="line">        B.rescale_col(i, factor)</span><br><span class="line"></span><br><span class="line">    B = B.dense_matrix().LLL()</span><br><span class="line"></span><br><span class="line">    B = B.change_ring(QQ)</span><br><span class="line">    <span class="keyword">for</span> i, factor <span class="keyword">in</span> <span class="built_in">enumerate</span>(factors):</span><br><span class="line">        B.rescale_col(i, <span class="number">1</span> / factor)</span><br><span class="line"></span><br><span class="line">    H = <span class="type">Sequence</span>([], f.parent().change_ring(QQ))</span><br><span class="line">    <span class="keyword">for</span> h <span class="keyword">in</span> <span class="built_in">filter</span>(<span class="literal">None</span>, B * monomials):</span><br><span class="line">        H.append(h)</span><br><span class="line">        I = H.ideal()</span><br><span class="line">        <span class="keyword">if</span> I.dimension() == -<span class="number">1</span>:</span><br><span class="line">            H.pop()</span><br><span class="line">        <span class="keyword">elif</span> I.dimension() == <span class="number">0</span>:</span><br><span class="line">            roots = []</span><br><span class="line">            <span class="keyword">for</span> root <span class="keyword">in</span> I.variety(ring=ZZ):</span><br><span class="line">                root = <span class="built_in">tuple</span>(R(root[var]) <span class="keyword">for</span> var <span class="keyword">in</span> f.variables())</span><br><span class="line">                roots.append(root)</span><br><span class="line">            <span class="keyword">return</span> roots</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">n = </span><br><span class="line">e = </span><br><span class="line">c = </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">P = Zmod(ZZ(e))[<span class="string">&quot;k,s&quot;</span>]</span><br><span class="line">k, s = P.gens()</span><br><span class="line">f = <span class="number">1</span> + k * (n - s)</span><br><span class="line">rs = small_roots(f, (<span class="number">2</span>**<span class="number">540</span>, <span class="number">2</span>**<span class="number">1025</span>), m=<span class="number">4</span>, d=<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(rs)</span><br><span class="line">k, s = <span class="built_in">map</span>(<span class="built_in">int</span>, rs[<span class="number">0</span>])</span><br><span class="line">phi = n - s</span><br><span class="line">d = <span class="built_in">pow</span>(e, -<span class="number">1</span>, phi)</span><br><span class="line">m = <span class="built_in">pow</span>(c, d, n)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(<span class="built_in">int</span>(m)))</span><br><span class="line"><span class="comment"># b&#x27;flag&#123;AL3XEI_FAKE_FLAG&#125;&#x27;</span></span><br></pre></td></tr></table></figure>



<h2 id="1-4-含多个素数的-RSA"><a href="#1-4-含多个素数的-RSA" class="headerlink" title="1.4 含多个素数的 RSA"></a>1.4 含多个素数的 RSA</h2><p>接下来的攻击将上述RSA攻击扩展到了含多个素数的形式。</p>
<p><strong>定理3.</strong> 令 $N$ 是含 $r$ 个素数（大小相近）的RSA，$d$ 为私钥指数，且满足 $\sqrt {2(2r-1)}|\phi(N)-d|&lt;N^{1&#x2F;(2r)}$。则公钥 $(N,e)$ 已知的情况下，在多项式时间  $N$ 内可以求得私钥。</p>
<p>证明过程与 Wiener 攻击近乎一致，不再阐述。</p>
<p><strong>定理4.</strong> 对针对含多个素数的RSA小私钥指数的，基于小逆元攻击的方法，如果在 $d&lt;N^\sigma$ 情况下成立，则在 $d&gt;\phi(N)-N^\sigma$ 情况下也成立。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> getPrime, bytes_to_long</span><br><span class="line"></span><br><span class="line">DEBUG = <span class="literal">True</span> </span><br><span class="line">p,q,r = [getPrime(<span class="number">1024</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="string">&quot;pqr&quot;</span>] </span><br><span class="line">n = p*q*r </span><br><span class="line">l = getPrime(<span class="number">490</span>)</span><br><span class="line">phi = (p - <span class="number">1</span>) * (q - <span class="number">1</span>) * (r - <span class="number">1</span>)</span><br><span class="line">d = phi - l </span><br><span class="line">e = <span class="built_in">int</span>(<span class="built_in">pow</span>(d, -<span class="number">1</span>, phi)) </span><br><span class="line"></span><br><span class="line">flag = <span class="string">b&#x27;flag&#123;AL3XEI_FAKE_FLAG&#125;&#x27;</span></span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line">c = <span class="built_in">pow</span>(m, e, n)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;n = &#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;e = &#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;c = &#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> DEBUG:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;down: &quot;</span>, <span class="built_in">int</span>((<span class="number">1</span>/<span class="number">3</span>)*(n**(<span class="number">1</span>/<span class="number">6</span>))).bit_length())  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;up: &quot;</span>, <span class="built_in">int</span>(<span class="built_in">pow</span>(n, <span class="number">0.292</span>)).bit_length())</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;k:&quot;</span>, <span class="built_in">int</span>((e*l+<span class="number">1</span>)//phi).bit_length()) </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;s:&quot;</span>, <span class="built_in">int</span>(-(- p*q-p*r-q*r+p+q+r-<span class="number">1</span>)).bit_length(), (e*l+<span class="number">1</span>)%phi)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">small_roots</span>(<span class="params">f, bounds, m=<span class="number">1</span>, d=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> d:</span><br><span class="line">        d = f.degree()</span><br><span class="line"></span><br><span class="line">    R = f.base_ring()</span><br><span class="line">    N = R.cardinality()</span><br><span class="line"></span><br><span class="line">    f /= f.coefficients().pop(<span class="number">0</span>)</span><br><span class="line">    f = f.change_ring(ZZ)</span><br><span class="line"></span><br><span class="line">    G = <span class="type">Sequence</span>([], f.parent())</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m + <span class="number">1</span>):</span><br><span class="line">        base = N ^ (m - i) * f ^ i</span><br><span class="line">        <span class="keyword">for</span> shifts <span class="keyword">in</span> itertools.product(<span class="built_in">range</span>(d), repeat=f.nvariables()):</span><br><span class="line">            g = base * prod(<span class="built_in">map</span>(power, f.variables(), shifts))</span><br><span class="line">            G.append(g)</span><br><span class="line"></span><br><span class="line">    B, monomials = G.coefficient_matrix()</span><br><span class="line">    monomials = vector(monomials)</span><br><span class="line"></span><br><span class="line">    factors = [monomial(*bounds) <span class="keyword">for</span> monomial <span class="keyword">in</span> monomials]</span><br><span class="line">    <span class="keyword">for</span> i, factor <span class="keyword">in</span> <span class="built_in">enumerate</span>(factors):</span><br><span class="line">        B.rescale_col(i, factor)</span><br><span class="line"></span><br><span class="line">    B = B.dense_matrix().LLL()</span><br><span class="line"></span><br><span class="line">    B = B.change_ring(QQ)</span><br><span class="line">    <span class="keyword">for</span> i, factor <span class="keyword">in</span> <span class="built_in">enumerate</span>(factors):</span><br><span class="line">        B.rescale_col(i, <span class="number">1</span> / factor)</span><br><span class="line"></span><br><span class="line">    H = <span class="type">Sequence</span>([], f.parent().change_ring(QQ))</span><br><span class="line">    <span class="keyword">for</span> h <span class="keyword">in</span> <span class="built_in">filter</span>(<span class="literal">None</span>, B * monomials):</span><br><span class="line">        H.append(h)</span><br><span class="line">        I = H.ideal()</span><br><span class="line">        <span class="keyword">if</span> I.dimension() == -<span class="number">1</span>:</span><br><span class="line">            H.pop()</span><br><span class="line">        <span class="keyword">elif</span> I.dimension() == <span class="number">0</span>:</span><br><span class="line">            roots = []</span><br><span class="line">            <span class="keyword">for</span> root <span class="keyword">in</span> I.variety(ring=ZZ):</span><br><span class="line">                root = <span class="built_in">tuple</span>(R(root[var]) <span class="keyword">for</span> var <span class="keyword">in</span> f.variables())</span><br><span class="line">                roots.append(root)</span><br><span class="line">            <span class="keyword">return</span> roots</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">n = </span><br><span class="line">e = </span><br><span class="line">c = </span><br><span class="line"></span><br><span class="line">P = Zmod(ZZ(e))[<span class="string">&quot;k,s&quot;</span>]</span><br><span class="line">k, s = P.gens()</span><br><span class="line">f = <span class="number">1</span> + k * (n - s)</span><br><span class="line">rs = small_roots(f, (<span class="number">2</span>**<span class="number">490</span>, <span class="number">2</span>**<span class="number">2050</span>), m=<span class="number">4</span>, d=<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(rs)</span><br><span class="line">k, s = <span class="built_in">map</span>(<span class="built_in">int</span>, rs[<span class="number">0</span>])</span><br><span class="line">phi = n - s</span><br><span class="line">d = <span class="built_in">pow</span>(e, -<span class="number">1</span>, phi)</span><br><span class="line">m = <span class="built_in">pow</span>(c, d, n)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(<span class="built_in">int</span>(m)))</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="1-5-总结"><a href="#1-5-总结" class="headerlink" title="1.5 总结"></a>1.5 总结</h2><p>RSA私钥指数过大会导致与私钥指数过小一样不安全。特别的，对于RSA，私钥指数 $|d|&lt;N^{1&#x2F;4}\sqrt 6$ 与 $|d|&lt; N^{0.292}$ 都会带来不安全性。</p>
<h1 id="0x02-二次生成器的密码分析"><a href="#0x02-二次生成器的密码分析" class="headerlink" title="0x02 二次生成器的密码分析"></a>0x02 二次生成器的密码分析</h1><p><a target="_blank" rel="noopener" href="https://github.com/AL3XEI709/papers/blob/main/Cryptanalysis_of_the_Quadratic_Generator.pdf">Link</a></p>
<blockquote>
<p>令 $p$ 为素数，$a,c$ 为模 $p$ 有限域内的整数。<strong>二次生成器</strong> (QCG) 是一个由等式关系 $v_{n+1}&#x3D;av_n^2+c\mod p$ 构成的伪随机数序列 $(v_n)$ 。这篇论文展示了如果任意多个连续的 $v_n$ 的<strong>高位已知</strong>，就可以在多项式时间内<strong>还原初始变量</strong> $v_0$ (即使在参数 $c$ 未知的情况下)，前提是初始变量 $v_0$ 不在某些特殊值的小的子集里。</p>
</blockquote>
<h2 id="2-1-二次生成器"><a href="#2-1-二次生成器" class="headerlink" title="2.1 二次生成器"></a>2.1 二次生成器</h2><p>令 $p$ 为素数，$a,c$ 为模 $p$ 有限域内的整数。<strong>二次生成器</strong> (QCG) 是一个由等式关系 $v_{n+1}&#x3D;av_n^2+c\mod p$ 构成的伪随机数序列 $(v_n)$ 。等式中的 $a, c$​ 分别被称为乘子和偏移量。</p>
<p>在密码设置中，初始量 $v_0$ 以及常量 $a, c$ 应该被设为私钥，利用生成器生成流密码。显然，如果多个连续的 $v_n$ 已知，求得 $v_0,a,c$ 是很容易的。所以在这个设置中，我们只输出 $v_n$ 的最高有效位 (msb) ，希望能让输出的序列更难预测。这篇论文展示的就是在这种情况下如何预测 $v_{n+j}$ 。</p>
<p>假设序列 $(v_n)$ 未知，但对于给定的 $n$ ，一些近似值 $w_j$ 已知。以下分别讨论 $a,c$ 公开和 $a$ 公开，$c$ 不公开的两种情况下，如果 $w_j$ 条件足够好，$v_{n+j}$ 和 $a$ 就能在多项式内还原。</p>
<p>在开始前，还要定义一个参数 $\Delta$ ，用来衡量 $w_j$ 近似 $v_{n+j}$ 的程度。这个参数通常假设为 $\Delta &lt; p$ 。更确切地，$w$ 是 $u$ 的 $\Delta$ - 近似，等价于 $|w-u|&lt;\Delta$ 。</p>
<h2 id="2-2-乘子与偏移量已知，预测二次生成器"><a href="#2-2-乘子与偏移量已知，预测二次生成器" class="headerlink" title="2.2 乘子与偏移量已知，预测二次生成器"></a>2.2 乘子与偏移量已知，预测二次生成器</h2><p><strong>定理1.</strong> 令 $p$ 为素数，$\Delta$ 为 整数且 $p&gt;\Delta&gt;1$ 。对任意 $a, c\in F_p $ ，存在一个算法，当 $a,c$ 与二次生成器产生的两个连续的值 $v_0,v_1$  $\Delta$-近似的 $w_0,w_1$ 已知时，在多项式时间内返回 $v_0$ 的值。</p>
<p>令 $\varepsilon_j&#x3D;v_j-w_j,j&#x3D;0,1$ 。由 $v_1\equiv av_0^2+c\mod p$ ，可得<br>$$<br>w_1+\varepsilon_1-a(w_0+\varepsilon_0)^2-c\equiv0\mod p<br>$$<br>令<br>$$<br>A\equiv(w_1-aw_0^2-c)\mod p, \qquad B_1\equiv-2aw_0\Delta\mod p,\<br>B_2\equiv\Delta\mod p,\qquad C\equiv-a\Delta^2\mod p<br>$$<br>可得<br>$$<br>A\Delta^2+B_1\Delta\varepsilon_0+B_2\Delta\varepsilon_1+C\varepsilon_0^2\equiv0\mod p<br>$$<br>因此由同余式<br>$$<br>Ax_0+B_1x_1+B_2x_2+Cx_3\equiv0\mod p,\<br>x_0\equiv0\mod \Delta^2,\<br>x_1\equiv x_2\equiv0\mod \Delta<br>$$<br>构成的格 $L$ 含有解  $x&#x3D;(x_0,x_1,x_2,x_3)\in ZZ^4$ 。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint </span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> * </span><br><span class="line"></span><br><span class="line">Bits = <span class="number">512</span></span><br><span class="line">UnKnownBits = <span class="number">146</span> </span><br><span class="line">flag = <span class="string">b&#x27;flag&#123;AL3XEI_FAKE_FLAG&#125;&#x27;</span> </span><br><span class="line"></span><br><span class="line">p = getPrime(Bits) </span><br><span class="line">a, c = [randint(<span class="number">0</span>, p) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="string">&quot;ac&quot;</span>] </span><br><span class="line"></span><br><span class="line">v_0 = bytes_to_long(flag) </span><br><span class="line">v_1 = (a*v_0**<span class="number">2</span>+c)%p </span><br><span class="line">v_2 = (a*v_1**<span class="number">2</span>+c)%p  </span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;a = <span class="subst">&#123;a&#125;</span>&quot;</span>) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;c = <span class="subst">&#123;c&#125;</span>&quot;</span>) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;p = <span class="subst">&#123;p&#125;</span>&quot;</span>) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;high_v1 = <span class="subst">&#123;v_1&gt;&gt;UnKnownBits&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;high_v2 = <span class="subst">&#123;v_2&gt;&gt;UnKnownBits&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">small_roots</span>(<span class="params">f, bounds, m=<span class="number">1</span>, d=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> d:</span><br><span class="line">        d = f.degree()</span><br><span class="line"></span><br><span class="line">    R = f.base_ring()</span><br><span class="line">    N = R.cardinality()</span><br><span class="line"></span><br><span class="line">    f /= f.coefficients().pop(<span class="number">0</span>)</span><br><span class="line">    f = f.change_ring(ZZ)</span><br><span class="line"></span><br><span class="line">    G = <span class="type">Sequence</span>([], f.parent())</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m + <span class="number">1</span>):</span><br><span class="line">        base = N ^ (m - i) * f ^ i</span><br><span class="line">        <span class="keyword">for</span> shifts <span class="keyword">in</span> itertools.product(<span class="built_in">range</span>(d), repeat=f.nvariables()):</span><br><span class="line">            g = base * prod(<span class="built_in">map</span>(power, f.variables(), shifts))</span><br><span class="line">            G.append(g)</span><br><span class="line"></span><br><span class="line">    B, monomials = G.coefficient_matrix()</span><br><span class="line">    monomials = vector(monomials)</span><br><span class="line"></span><br><span class="line">    factors = [monomial(*bounds) <span class="keyword">for</span> monomial <span class="keyword">in</span> monomials]</span><br><span class="line">    <span class="keyword">for</span> i, factor <span class="keyword">in</span> <span class="built_in">enumerate</span>(factors):</span><br><span class="line">        B.rescale_col(i, factor)</span><br><span class="line"></span><br><span class="line">    B = B.dense_matrix().LLL()</span><br><span class="line"></span><br><span class="line">    B = B.change_ring(QQ)</span><br><span class="line">    <span class="keyword">for</span> i, factor <span class="keyword">in</span> <span class="built_in">enumerate</span>(factors):</span><br><span class="line">        B.rescale_col(i, <span class="number">1</span> / factor)</span><br><span class="line"></span><br><span class="line">    H = <span class="type">Sequence</span>([], f.parent().change_ring(QQ))</span><br><span class="line">    <span class="keyword">for</span> h <span class="keyword">in</span> <span class="built_in">filter</span>(<span class="literal">None</span>, B * monomials):</span><br><span class="line">        H.append(h)</span><br><span class="line">        I = H.ideal()</span><br><span class="line">        <span class="keyword">if</span> I.dimension() == -<span class="number">1</span>:</span><br><span class="line">            H.pop()</span><br><span class="line">        <span class="keyword">elif</span> I.dimension() == <span class="number">0</span>:</span><br><span class="line">            roots = []</span><br><span class="line">            <span class="keyword">for</span> root <span class="keyword">in</span> I.variety(ring=ZZ):</span><br><span class="line">                root = <span class="built_in">tuple</span>(R(root[var]) <span class="keyword">for</span> var <span class="keyword">in</span> f.variables())</span><br><span class="line">                roots.append(root)</span><br><span class="line">            <span class="keyword">return</span> roots</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> []</span><br><span class="line">a = </span><br><span class="line">c = </span><br><span class="line">p = </span><br><span class="line">high_v1 = </span><br><span class="line">high_v2 = </span><br><span class="line">PR = Zmod(ZZ(p))[<span class="string">&quot;l1, l2&quot;</span>] </span><br><span class="line">l1, l2 = PR.gens() </span><br><span class="line">f = a*(high_v1*(<span class="number">2</span>^<span class="number">146</span>)+l1)^<span class="number">2</span>+c-(high_v2*(<span class="number">2</span>^<span class="number">146</span>)+l2)</span><br><span class="line">low_v1 = ZZ(small_roots(f, (<span class="number">2</span>^<span class="number">146</span>, <span class="number">2</span>^<span class="number">146</span>), m=<span class="number">3</span>, d=<span class="number">4</span>)[<span class="number">0</span>][<span class="number">0</span>]) </span><br><span class="line"></span><br><span class="line">v_0 = mod(((high_v1*(<span class="number">2</span>^<span class="number">146</span>)+low_v1)-c)*inverse_mod(a, p)%p, p).sqrt() </span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(ZZ(v_0)))</span><br></pre></td></tr></table></figure>



<h2 id="2-3-乘子已知，偏移量未知，预测二次生成器"><a href="#2-3-乘子已知，偏移量未知，预测二次生成器" class="headerlink" title="2.3 乘子已知，偏移量未知，预测二次生成器"></a>2.3 乘子已知，偏移量未知，预测二次生成器</h2><p><strong>定理2.</strong> 令 $p$ 为素数，$\Delta$ 为 整数且 $p&gt;\Delta&gt;1$ 。对任意 $a, c\in F_p $ ，存在一个算法，当 $a$ 与二次生成器产生的三个连续的值 $v_0,v_1,v_2$  $\Delta$-近似的 $w_0,w_1,w_2$ 已知时，在多项式时间内返回 $v_0$​ 的值。</p>
<p>令 $v_i&#x3D;w_i+\varepsilon_i,|\varepsilon_i|&lt;\Delta,i&#x3D;0,1,2$ ，且 $av_i^2+c&#x3D;v_{i+1}\mod p,i&#x3D;0,1$ ，可得含已知量 $a,w_i$ 和未知量 $\varepsilon_i$ 的方程：<br>$$<br>(aw_0^2-w_1-aw_1^2+w_2)+2aw_0\varepsilon_0-\<br>(1+2aw_1)\varepsilon_1+\varepsilon_2+a(\varepsilon_0^2-\varepsilon_1^2)\equiv 0\mod p<br>$$<br>向量 $(1,\varepsilon_0,\varepsilon_1,\varepsilon_2,\varepsilon_0^2-\varepsilon1^2 )$ 满足已知的一致性系数。为了使量标更平衡，将上式写作：<br>$$<br>(aw_0^2-w_1-aw_1^2+w_2)\Delta^2+2aw_0\Delta\Delta\varepsilon_0-(1+2aw_1)\Delta\Delta\varepsilon_1+\<br>+\Delta\Delta\varepsilon_2+a\Delta^2(\varepsilon_0^2-\varepsilon_1^2)\equiv0\mod p<br>$$<br>因此由同余式<br>$$<br>(aw_0^2-w_1-aw_1^2+w_2)x_0+2aw_0\Delta x_1-(1+2aw_1)\Delta x_2+\<br>+\Delta x_3+a\Delta^2 x_4\equiv0\mod p,\<br>x_0\equiv0\pmod \Delta^2,\<br>x_1,x_2,x_3\equiv0\mod \Delta<br>$$<br>构成的格 $L$ 含有解 $e&#x3D;(\Delta^2,\Delta\varepsilon_0,\Delta\varepsilon_1,\Delta\varepsilon_2,\varepsilon_0^2-\varepsilon_1^2)\in ZZ^5$ 。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint </span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> * </span><br><span class="line"></span><br><span class="line">Bits = <span class="number">256</span></span><br><span class="line">UnKnownBits = <span class="number">48</span></span><br><span class="line">flag = <span class="string">b&#x27;flag&#123;AL3XEI_FAKE_FLAG&#125;&#x27;</span> </span><br><span class="line"></span><br><span class="line">p = getPrime(Bits) </span><br><span class="line">a, c = [randint(<span class="number">0</span>, p) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="string">&quot;ac&quot;</span>] </span><br><span class="line">v_0 = bytes_to_long(flag) </span><br><span class="line"><span class="keyword">assert</span> v_0&lt;p</span><br><span class="line">v_1 = (a*v_0**<span class="number">2</span>+c)%p </span><br><span class="line">v_2 = (a*v_1**<span class="number">2</span>+c)%p  </span><br><span class="line">v_3 = (a*v_2**<span class="number">2</span>+c)%p  </span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;a = <span class="subst">&#123;a&#125;</span>&quot;</span>) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;p = <span class="subst">&#123;p&#125;</span>&quot;</span>) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;high_v0 = <span class="subst">&#123;v_1&gt;&gt;UnKnownBits&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;high_v1 = <span class="subst">&#123;v_2&gt;&gt;UnKnownBits&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;high_v2 = <span class="subst">&#123;v_3&gt;&gt;UnKnownBits&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">small_roots</span>(<span class="params">f, bounds, m=<span class="number">1</span>, d=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> d:</span><br><span class="line">        d = f.degree()</span><br><span class="line"></span><br><span class="line">    R = f.base_ring()</span><br><span class="line">    N = R.cardinality()</span><br><span class="line"></span><br><span class="line">    f /= f.coefficients().pop(<span class="number">0</span>)</span><br><span class="line">    f = f.change_ring(ZZ)</span><br><span class="line"></span><br><span class="line">    G = <span class="type">Sequence</span>([], f.parent())</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m + <span class="number">1</span>):</span><br><span class="line">        base = N ^ (m - i) * f ^ i</span><br><span class="line">        <span class="keyword">for</span> shifts <span class="keyword">in</span> itertools.product(<span class="built_in">range</span>(d), repeat=f.nvariables()):</span><br><span class="line">            g = base * prod(<span class="built_in">map</span>(power, f.variables(), shifts))</span><br><span class="line">            G.append(g)</span><br><span class="line"></span><br><span class="line">    B, monomials = G.coefficient_matrix()</span><br><span class="line">    monomials = vector(monomials)</span><br><span class="line"></span><br><span class="line">    factors = [monomial(*bounds) <span class="keyword">for</span> monomial <span class="keyword">in</span> monomials]</span><br><span class="line">    <span class="keyword">for</span> i, factor <span class="keyword">in</span> <span class="built_in">enumerate</span>(factors):</span><br><span class="line">        B.rescale_col(i, factor)</span><br><span class="line"></span><br><span class="line">    B = B.dense_matrix().LLL()</span><br><span class="line"></span><br><span class="line">    B = B.change_ring(QQ)</span><br><span class="line">    <span class="keyword">for</span> i, factor <span class="keyword">in</span> <span class="built_in">enumerate</span>(factors):</span><br><span class="line">        B.rescale_col(i, <span class="number">1</span> / factor)</span><br><span class="line"></span><br><span class="line">    H = <span class="type">Sequence</span>([], f.parent().change_ring(QQ))</span><br><span class="line">    <span class="keyword">for</span> h <span class="keyword">in</span> <span class="built_in">filter</span>(<span class="literal">None</span>, B * monomials):</span><br><span class="line">        H.append(h)</span><br><span class="line">        I = H.ideal()</span><br><span class="line">        <span class="keyword">if</span> I.dimension() == -<span class="number">1</span>:</span><br><span class="line">            H.pop()</span><br><span class="line">        <span class="keyword">elif</span> I.dimension() == <span class="number">0</span>:</span><br><span class="line">            roots = []</span><br><span class="line">            <span class="keyword">for</span> root <span class="keyword">in</span> I.variety(ring=ZZ):</span><br><span class="line">                root = <span class="built_in">tuple</span>(R(root[var]) <span class="keyword">for</span> var <span class="keyword">in</span> f.variables())</span><br><span class="line">                roots.append(root)</span><br><span class="line">            <span class="keyword">return</span> roots</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">UnKnownBits = <span class="number">48</span></span><br><span class="line">a = </span><br><span class="line">p = </span><br><span class="line">high_v0 = </span><br><span class="line">high_v1 = </span><br><span class="line">high_v2 = </span><br><span class="line"></span><br><span class="line">high_v0 = high_v0&lt;&lt;UnKnownBits</span><br><span class="line">high_v1 = high_v1&lt;&lt;UnKnownBits</span><br><span class="line">high_v2 = high_v2&lt;&lt;UnKnownBits</span><br><span class="line"></span><br><span class="line">PR = Zmod(ZZ(p))[<span class="string">&quot;l0, l1, l2&quot;</span>] </span><br><span class="line">l0, l1, l2 = PR.gens() </span><br><span class="line">f =( a*high_v0^<span class="number">2</span>-high_v1-a*high_v1^<span class="number">2</span>+high_v2 ) + <span class="number">2</span>*a*high_v0*l0 - (<span class="number">1</span>+<span class="number">2</span>*a*high_v1)*l1 + l2 + a*(l0^<span class="number">2</span>-l1^<span class="number">2</span>) </span><br><span class="line"></span><br><span class="line">ls = small_roots(f, (<span class="number">2</span>^UnKnownBits, <span class="number">2</span>^UnKnownBits, <span class="number">2</span>^UnKnownBits), m=<span class="number">3</span>, d=<span class="number">4</span>)</span><br><span class="line">v_0, v_1, v_2 = high_v0+ZZ(ls[<span class="number">0</span>][<span class="number">0</span>]), high_v1+ZZ(ls[<span class="number">0</span>][<span class="number">1</span>]), high_v2+ZZ(ls[<span class="number">0</span>][<span class="number">2</span>]) </span><br><span class="line">c = (v_1 - a*v_0^<span class="number">2</span>) </span><br><span class="line"></span><br><span class="line">sd = mod((v_0-c)*inverse_mod(a, p)%p, p).sqrt() </span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(ZZ(sd)))</span><br></pre></td></tr></table></figure>



<h2 id="2-4-总结-尚未解决的问题"><a href="#2-4-总结-尚未解决的问题" class="headerlink" title="2.4 总结 &amp; 尚未解决的问题"></a>2.4 总结 &amp; 尚未解决的问题</h2><p>显然定理1的界 $\Delta&#x3D;O(p^{1&#x2F;4})$ ，定理2的界 $\Delta&#x3D;O(p^{1&#x2F;5})$ 。因此是否能提高 $\Delta$​ 的界值得讨论。</p>
<p>在 $c$ 给出但乘子 $a$ 未知的条件下也能用类似的过程预测二次生成器。</p>
<p>目前还不清楚当模数 $p$ 未知时如何预测二次生成器。</p>
<h1 id="0x03-在攻击变体-RSA-中找到具有新应用的多元多项式根的策略"><a href="#0x03-在攻击变体-RSA-中找到具有新应用的多元多项式根的策略" class="headerlink" title="0x03 在攻击变体 RSA 中找到具有新应用的多元多项式根的策略"></a>0x03 在攻击变体 RSA 中找到具有新应用的多元多项式根的策略</h1><p><a target="_blank" rel="noopener" href="https://github.com/AL3XEI709/papers/blob/main/jochemszmay.pdf">Link</a></p>
<blockquote>
<p>这篇论文展示了利用<strong>格基 Coppersmith</strong> 技术计算多元模多项式<strong>小整数根</strong>的策略。应用该策略，该论文得出在多项式时间内攻击两种 <strong>RSA 变体</strong>的方法。首先是 Qiao-Lam scheme, 其利用中国剩余定理在解密过程发挥作用。然后是共素数 RSA ，其素数生成的方法能抵抗 Wiener 攻击。</p>
</blockquote>
<h2 id="1-1-jochemsz-may-方法"><a href="#1-1-jochemsz-may-方法" class="headerlink" title="1.1 jochemsz_may 方法"></a>1.1 jochemsz_may 方法</h2><p>论文开篇回顾了了 Coppersmith 以及 boneh Durfee 基于 Coppersmith 设计的针对 RSA 的攻击，并指出：找到一个小根的多项式 $f$ 的分析严重依赖于 $f$ 中出现的单项式，因此每个新的多项式都必须重新进行分析。这个工作无疑是十分繁杂的。2005年，Blomer 和 May 展示了如何寻找二元多项式小整数根的最佳界限。在本文中，我们提出了一种启发式策略，适用于所有多元多项式；无论是具有模数根还是整数根。</p>
<h2 id="1-2-参数的设定"><a href="#1-2-参数的设定" class="headerlink" title="1.2 参数的设定"></a>1.2 参数的设定</h2><p>令多项式 $f(x,ym,z)&#x3D;a_0+a_1x+a_2x^2+a_3y+a_4z+a_5xy+a_6xz+a_7yz$ 有小根 $(x^0,y^0,z^0)$ ，$x,y,z$ 的上界分别为 $X,Y,Z$ 。根据论文提出的新策略，所有小根都能有效的在多项式时间 $logW$ 内恢复出来，前提是满足<br>$$<br>X^{(7+8\tau+3\tau^2)}(YZ)^{5+\frac{9}{2}\tau}&lt;W^{3+3\tau-\epsilon}<br>$$<br>同时，论文明确给出 $W&#x3D;||f(x_1X_n,\dots,x_nX_n)||<em>\infty$ ，而 $||f(x_1,\dots,x_n)||</em>{\infty}$ 的意思就是多项式的最大系数，所以 $W$ 就是多项式对各 $x$ 进行 $Xx$ 代入后的最大系数。举个例子，如 $f&#x3D;2x^2+3x+4$ ， $X&#x3D;2$ ，则 $||f(x_1X_n,\dots,x_nX_n)||&#x3D;8x^2+6x+4$ ，显然最大系数在 $x^2$ ，即 $W&#x3D;8$ 。</p>
<h2 id="1-3-对-共素-RSA-的攻击"><a href="#1-3-对-共素-RSA-的攻击" class="headerlink" title="1.3 对 共素 RSA 的攻击"></a>1.3 对 共素 RSA 的攻击</h2><p><strong>定理1.</strong> 对任意 $\epsilon&gt;0$ , 存在 $n$ 使以下成立：令$N&#x3D;pq$ 为 $n$ 比特 的 RSA 模数，$p,q$ 为 $\frac{n}{2}$ 比特的素数，且 $p-1&#x3D;2ga,q-1&#x3D;2gb$ , $g$ 位数为 $\gamma n$ ，$0&lt;\gamma&lt;\frac{1}{2}$ 。令 $ed\equiv1\mod {2gab}$ , $bitsize(e)&#x3D;(1-\gamma)n,bitsize(d)&#x3D;\delta n$ , 其中 $0&lt;\delta&lt;(1-\gamma n)$ , 则 $d$ 可以在<br>$$<br>\delta&lt;\frac{1}{4}(4+4\gamma-\sqrt{13+20\gamma+4\gamma^2})-\epsilon<br>$$<br>的前提下，在多项式时间  $\log N$ 时间内求出。</p>
<p>由上式可得：<br>$$<br>ed&#x3D;1+k(p-1)b,ed&#x3D;1+k(q-1)a<br>$$<br>联立两个式子：$e^2d^2+ed(ka+kb-2)-(N-1)k^2ab-(ka+kb-1)&#x3D;0$ 。这个方程也可以写成 $f(x,y,z)&#x3D;e^2x^2+ex(y+z-2)-(y+z-1)z-(N-1)yz$ , 它的小根为 $(d,ka,kb)$ , 上界为 $X&#x3D;N^\delta,Y&#x3D;N^{\delta+\frac{1}{2}-\gamma},Z&#x3D;N^{\delta+\frac{1}{2}-\gamma}$ 。同时也可以算出 $W&#x3D;N^{2+2\gamma-2\delta}$  。</p>
<p>论文给出了几个实现攻击需要的参数列表。</p>
<p><img src="https://gitee.com/alekseyp/picgo/raw/master/img/202403031656231.png" alt="image-20240303165643981"> </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">n = <span class="number">4092</span> </span><br><span class="line">gamma = <span class="number">0.4</span></span><br><span class="line">delta = <span class="number">0.1604</span></span><br><span class="line">flag = <span class="string">b&#x27;AL3XEI_FAKE_FLAG&#x27;</span> </span><br><span class="line"></span><br><span class="line">g = getPrime(<span class="built_in">int</span>(n*gamma)) </span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    p = getPrime(n//<span class="number">2</span>) </span><br><span class="line">    <span class="keyword">if</span> (p-<span class="number">1</span>)%(<span class="number">2</span>*g) == <span class="number">0</span> :</span><br><span class="line">        <span class="keyword">break</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    q = getPrime(n//<span class="number">2</span>) </span><br><span class="line">    <span class="keyword">if</span> (q-<span class="number">1</span>)%(<span class="number">2</span>*g) == <span class="number">0</span> :</span><br><span class="line">        <span class="keyword">break</span> </span><br><span class="line"></span><br><span class="line">a, b = (p-<span class="number">1</span>)//(<span class="number">2</span>*g), (q-<span class="number">1</span>)//(<span class="number">2</span>*g) </span><br><span class="line">N = p*q </span><br><span class="line">d = getPrime(<span class="built_in">int</span>(n*delta)) </span><br><span class="line">e = inverse_mod(d, <span class="number">2</span>*g*a*b) </span><br><span class="line"></span><br><span class="line">m = bytes_to_long(flag) </span><br><span class="line">c = <span class="built_in">pow</span>(m,e,n) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;n = <span class="subst">&#123;n&#125;</span>&#x27;</span>) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;e = <span class="subst">&#123;e&#125;</span>&#x27;</span>) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;c = <span class="subst">&#123;c&#125;</span>&#x27;</span>) </span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sage.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># display matrix picture with 0 and X</span></span><br><span class="line"><span class="comment"># references: https://github.com/mimoo/RSA-and-LLL-attacks/blob/master/boneh_durfee.sage</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">matrix_overview</span>(<span class="params">BB</span>):</span><br><span class="line">    <span class="keyword">for</span> ii <span class="keyword">in</span> <span class="built_in">range</span>(BB.dimensions()[<span class="number">0</span>]):</span><br><span class="line">        a = (<span class="string">&#x27;%03d &#x27;</span> % ii)</span><br><span class="line">        <span class="keyword">for</span> jj <span class="keyword">in</span> <span class="built_in">range</span>(BB.dimensions()[<span class="number">1</span>]):</span><br><span class="line">            a += <span class="string">&#x27;0&#x27;</span> <span class="keyword">if</span> BB[ii,jj] == <span class="number">0</span> <span class="keyword">else</span> <span class="string">&#x27;X&#x27;</span></span><br><span class="line">            <span class="keyword">if</span> BB.dimensions()[<span class="number">0</span>] &lt; <span class="number">60</span>:</span><br><span class="line">                a += <span class="string">&#x27; &#x27;</span></span><br><span class="line">        <span class="built_in">print</span> (a)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sort_monomials</span>(<span class="params">monomials</span>):</span><br><span class="line">    x, y, z = monomials[<span class="number">0</span>].parent().gens()</span><br><span class="line">    Mx = []</span><br><span class="line">    My = []</span><br><span class="line">    Mz = []</span><br><span class="line">    degx = <span class="built_in">max</span>([monomial.degree(x) <span class="keyword">for</span> monomial <span class="keyword">in</span> monomials])</span><br><span class="line">    degy = <span class="built_in">max</span>([monomial.degree(y) <span class="keyword">for</span> monomial <span class="keyword">in</span> monomials])</span><br><span class="line">    degz = <span class="built_in">max</span>([monomial.degree(z) <span class="keyword">for</span> monomial <span class="keyword">in</span> monomials])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(degx + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(degy + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(degz + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> k+j &gt; i:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                mono = x^i * y^j * z^k</span><br><span class="line">                <span class="keyword">if</span> mono <span class="keyword">in</span> monomials:</span><br><span class="line">                    Mx += [mono]</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(degy + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(degz + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(degx + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> k &gt; j:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                mono = x^i * y^j * z^k</span><br><span class="line">                <span class="keyword">if</span> mono <span class="keyword">in</span> monomials <span class="keyword">and</span> mono <span class="keyword">not</span> <span class="keyword">in</span> Mx:</span><br><span class="line">                    My += [mono]</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(degz + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(degy + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(degx + <span class="number">1</span>):</span><br><span class="line">                mono = x^i * y^j * z^k</span><br><span class="line">                <span class="keyword">if</span> mono <span class="keyword">in</span> monomials <span class="keyword">and</span> mono <span class="keyword">not</span> <span class="keyword">in</span> (Mx+My):</span><br><span class="line">                    Mz += [mono]</span><br><span class="line">    <span class="keyword">return</span> Mx + My + Mz</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">jochemsz_may_trivariate</span>(<span class="params">pol, XX, YY, ZZ, WW, tau, mm</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    Implementation of Finding roots of trivariate polynomial [1].</span></span><br><span class="line"><span class="string">    Thanks @Bono_iPad</span></span><br><span class="line"><span class="string">    References: </span></span><br><span class="line"><span class="string">        [1] Ellen Jochemsz and Alexander May. &quot;A Strategy for Finding Roots of Multivariate Polynomials with New Applications in Attacking RSA Variants&quot;</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    tt = floor(mm * tau)</span><br><span class="line">    cond = XX^(<span class="number">7</span> + <span class="number">9</span>*tau + <span class="number">3</span>*tau^<span class="number">2</span>) * (YY*ZZ)^(<span class="number">5</span>+<span class="number">9</span>/<span class="number">2</span>*tau) &lt; WW^(<span class="number">3</span> + <span class="number">3</span>*tau)</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&#x27;[+] Bound check: X^&#123;7+9tau+3tau^2&#125; * (YZ)^&#123;5+9/2tau&#125; &lt; W^&#123;3+3tau&#125;:&#x27;</span>, )</span><br><span class="line">    <span class="keyword">if</span> cond:</span><br><span class="line">        <span class="built_in">print</span>( <span class="string">&#x27;OK&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&#x27;NG&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Polynomial constant coefficient (a_0) must be 1</span></span><br><span class="line">    <span class="comment"># <span class="doctag">XXX:</span> can a_0 be zero?</span></span><br><span class="line">    f_ = pol</span><br><span class="line">    a0 = f_.constant_coefficient()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> gcd(a0, XX) != <span class="number">1</span>:</span><br><span class="line">        XX += <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> gcd(a0, YY) != <span class="number">1</span>:</span><br><span class="line">        YY += <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> gcd(a0, ZZ) != <span class="number">1</span>:</span><br><span class="line">        ZZ += <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> gcd(a0, WW) != <span class="number">1</span>:</span><br><span class="line">        WW += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    RR = WW * XX^(<span class="number">2</span>*(mm-<span class="number">1</span>)+tt) * (YY*ZZ)^(mm-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> a0 != <span class="number">0</span>:</span><br><span class="line">        F = Zmod(RR)</span><br><span class="line">        PK = PolynomialRing(F, <span class="string">&#x27;xs, ys, zs&#x27;</span>)</span><br><span class="line">        f_ = PR(PK(f_) * F(a0)^-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Construct set `S` (cf.[1] p.8)</span></span><br><span class="line">    S = <span class="built_in">set</span>()</span><br><span class="line">    <span class="keyword">for</span> i2, i3 <span class="keyword">in</span> itertools.product(<span class="built_in">range</span>(<span class="number">0</span>, mm), repeat=<span class="number">2</span>):</span><br><span class="line">        <span class="keyword">for</span> i1 <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">2</span>*(mm-<span class="number">1</span>) - (i2 + i3) + tt + <span class="number">1</span>):</span><br><span class="line">            S.add(x^i1 * y^i2 * z^i3)</span><br><span class="line">    m_S = []</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(mm):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(mm):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>*(mm-<span class="number">1</span>) - (i2 + i3) + tt + <span class="number">1</span>):</span><br><span class="line">                m_S += [x^i*y^j*z^k]</span><br><span class="line">    S = m_S</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Construct set `M` (cf.[1] p.8)</span></span><br><span class="line">    M = <span class="built_in">set</span>()</span><br><span class="line">    <span class="keyword">for</span> i2, i3 <span class="keyword">in</span> itertools.product(<span class="built_in">range</span>(<span class="number">0</span>, mm + <span class="number">1</span>), repeat=<span class="number">2</span>):</span><br><span class="line">        <span class="keyword">for</span> i1 <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">2</span>*mm - (i2 + i3) + tt + <span class="number">1</span>):</span><br><span class="line">            M.add(x^i1 * y^i2 * z^i3)</span><br><span class="line">    M_S = <span class="built_in">list</span>(M - <span class="built_in">set</span>(S))</span><br><span class="line"></span><br><span class="line">    m_M_S = []</span><br><span class="line">    deg_x = <span class="built_in">max</span>([mono.degree(x) <span class="keyword">for</span> mono <span class="keyword">in</span> M_S])</span><br><span class="line">    deg_y = <span class="built_in">max</span>([mono.degree(y) <span class="keyword">for</span> mono <span class="keyword">in</span> M_S])</span><br><span class="line">    deg_z = <span class="built_in">max</span>([mono.degree(z) <span class="keyword">for</span> mono <span class="keyword">in</span> M_S])</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(deg_z + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(deg_y + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(deg_x + <span class="number">1</span>):</span><br><span class="line">                mono = x^i*y^j*z^k</span><br><span class="line">                <span class="keyword">if</span> mono <span class="keyword">in</span> M_S:</span><br><span class="line">                    m_M_S += [mono]</span><br><span class="line">    M_S = m_M_S</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Construct polynomial `g`, `g&#x27;` for basis of lattice</span></span><br><span class="line">    g = []</span><br><span class="line">    g_ = []</span><br><span class="line">    M_S = sort_monomials(M_S)</span><br><span class="line">    S = sort_monomials(S)</span><br><span class="line">    <span class="keyword">for</span> monomial <span class="keyword">in</span> S:</span><br><span class="line">        i1 = monomial.degree(x)</span><br><span class="line">        i2 = monomial.degree(y)</span><br><span class="line">        i3 = monomial.degree(z)</span><br><span class="line">        g += [monomial * f_ * XX^(<span class="number">2</span>*(mm-<span class="number">1</span>)+tt-i1) * YY^(mm-<span class="number">1</span>-i2) * ZZ^(mm-<span class="number">1</span>-i3)]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> monomial <span class="keyword">in</span> M_S:</span><br><span class="line">        g_ += [monomial * RR]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Construct Lattice from `g`, `g&#x27;`</span></span><br><span class="line">    monomials_G = []</span><br><span class="line">    monomials = []</span><br><span class="line">    G = g + g_</span><br><span class="line">    deg_x = deg_y = deg_z = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> g_poly <span class="keyword">in</span> G:</span><br><span class="line">        monomials_G += g_poly.monomials()</span><br><span class="line">        deg_x = <span class="built_in">max</span>(deg_x, g_poly.degree(x))</span><br><span class="line">        deg_y = <span class="built_in">max</span>(deg_y, g_poly.degree(y))</span><br><span class="line">        deg_z = <span class="built_in">max</span>(deg_z, g_poly.degree(z))</span><br><span class="line">    monomials_G = <span class="built_in">sorted</span>(<span class="built_in">set</span>(monomials_G))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(deg_z + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(deg_y + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(deg_x + <span class="number">1</span>):</span><br><span class="line">                mono = x^i*y^j*z^k</span><br><span class="line">                <span class="keyword">if</span> mono <span class="keyword">in</span> monomials_G:</span><br><span class="line">                    monomials += [x^i*y^j*z^k]</span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">len</span>(monomials) == <span class="built_in">len</span>(G)</span><br><span class="line">    monomials = sort_monomials(monomials)</span><br><span class="line">    dims = <span class="built_in">len</span>(monomials)</span><br><span class="line">    M = Matrix(IntegerRing(), dims)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(dims):</span><br><span class="line">        M[i, <span class="number">0</span>] = G[i](<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(dims):</span><br><span class="line">            <span class="keyword">if</span> monomials[j] <span class="keyword">in</span> G[i].monomials():</span><br><span class="line">                M[i, j] = G[i].monomial_coefficient(monomials[j]) * monomials[j](XX, YY, ZZ)</span><br><span class="line">    matrix_overview(M)</span><br><span class="line">    <span class="built_in">print</span> ()</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&#x27;=&#x27;</span> * <span class="number">128</span>)</span><br><span class="line">    <span class="built_in">print</span> ()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># LLL</span></span><br><span class="line"></span><br><span class="line">    start = time()</span><br><span class="line">    B = M.LLL()</span><br><span class="line">    matrix_overview(B)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;[+] LLL cost %d sec&#x27;</span> % (time() - start))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Re-construct polynomial `H_i` from Reduced-lattice</span></span><br><span class="line">    H = [(i, <span class="number">0</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(dims)]</span><br><span class="line">    H = <span class="built_in">dict</span>(H)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(dims):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(dims):</span><br><span class="line">            H[i] += PR((monomials[j] * B[i, j]) / monomials[j](XX, YY, ZZ))</span><br><span class="line"></span><br><span class="line">    PX = PolynomialRing(IntegerRing(), <span class="string">&#x27;xn&#x27;</span>)</span><br><span class="line">    xn = PX.gen()</span><br><span class="line">    PY = PolynomialRing(IntegerRing(), <span class="string">&#x27;yn&#x27;</span>)</span><br><span class="line">    yn = PX.gen()</span><br><span class="line">    PZ = PolynomialRing(IntegerRing(), <span class="string">&#x27;zn&#x27;</span>)</span><br><span class="line">    zn = PX.gen()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Solve for `x`</span></span><br><span class="line">    r1 = H[<span class="number">2</span>].resultant(pol, y)</span><br><span class="line">    r2 = H[<span class="number">3</span>].resultant(pol, y)</span><br><span class="line">    r3 = r1.resultant(r2, z)</span><br><span class="line">    x_roots = <span class="built_in">map</span>(<span class="keyword">lambda</span> t: t[<span class="number">0</span>], r3.subs(x=xn).roots())</span><br><span class="line">    x_roots = <span class="built_in">list</span>(x_roots)</span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">len</span>(x_roots) &gt; <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(x_roots) == <span class="number">1</span> <span class="keyword">and</span> x_roots[<span class="number">0</span>] == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&#x27;[-] Can\&#x27;t find non-trivial solution for `x`&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    x_root = x_roots[<span class="number">0</span>]</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&#x27;[+] Found x0 = %d&#x27;</span> % x_root)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Solve for `z`</span></span><br><span class="line">    r1_ = r1.subs(x=x_root)</span><br><span class="line">    r2_ = r2.subs(x=x_root)</span><br><span class="line">    z_roots = <span class="built_in">map</span>(<span class="keyword">lambda</span> t: t[<span class="number">0</span>], gcd(r1_, r2_).subs(z=zn).roots())</span><br><span class="line">    z_roots = <span class="built_in">list</span>(z_roots)</span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">len</span>(z_roots) &gt; <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(z_roots) == <span class="number">1</span> <span class="keyword">and</span> z_roots[<span class="number">0</span>] == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&#x27;[-] Can\&#x27;t find non-trivial solution for `z`&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    z_root = z_roots[<span class="number">0</span>]</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&#x27;[+] Found z0 = %d&#x27;</span> % z_root)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Solve for `y`</span></span><br><span class="line">    y_roots = <span class="built_in">map</span>(<span class="keyword">lambda</span> t: t[<span class="number">0</span>], H[<span class="number">2</span>].subs(x=x_root, z=z_root).subs(y=yn).roots())</span><br><span class="line">    y_roots = <span class="built_in">list</span>(y_roots)</span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">len</span>(y_roots) &gt; <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(y_roots) == <span class="number">1</span> <span class="keyword">and</span> y_roots[<span class="number">0</span>] == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&#x27;[-] Can\&#x27;t find non-trivial solution for `y`&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    y_root = y_roots[<span class="number">0</span>]</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&#x27;[+] Found y0 = %d&#x27;</span> % y_root)</span><br><span class="line">    <span class="keyword">assert</span> pol(x_root, y_root, z_root) == <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> (x_root, y_root, z_root)</span><br><span class="line"></span><br><span class="line">n = </span><br><span class="line">e = </span><br><span class="line">c = </span><br><span class="line"></span><br><span class="line">gamma = <span class="number">0.4</span></span><br><span class="line">delta = <span class="number">0.1604</span></span><br><span class="line"></span><br><span class="line">PR.&lt;x, y, z&gt; = PolynomialRing(ZZ)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Maximal value of solution `x0`, `y0`, `z0`</span></span><br><span class="line">XX = floor(n^delta)</span><br><span class="line">YY = floor(n^(delta + <span class="number">0.5</span> - gamma))</span><br><span class="line">ZZ = YY</span><br><span class="line"></span><br><span class="line"><span class="comment"># Norm of polynomial as vector representation</span></span><br><span class="line">WW = floor(n^(<span class="number">2</span> + <span class="number">2</span>*delta - <span class="number">2</span>*gamma))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Some Non-negative real ([SAN10] 3.1 (11))</span></span><br><span class="line">tau = (<span class="number">1</span>/<span class="number">2</span> + gamma - <span class="number">4</span>*delta) / (<span class="number">2</span>*delta)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Powering degree</span></span><br><span class="line">mm = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Target polynomial</span></span><br><span class="line">pol = e^<span class="number">2</span> * x^<span class="number">2</span> + e*x*(y+z-<span class="number">2</span>)-(y+z-<span class="number">1</span>)-(n-<span class="number">1</span>)*y*z</span><br><span class="line">x0, y0, z0 = jochemsz_may_trivariate(pol, XX, YY, ZZ, WW, tau, mm)</span><br><span class="line"></span><br><span class="line">d = x0 </span><br><span class="line">m = <span class="built_in">pow</span>(c,d,n) </span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(<span class="built_in">int</span>(m)))</span><br></pre></td></tr></table></figure>



<h1 id="0X04-带有小的未知乘子的隐藏数问题：MEGA-的六次查询密码分析以及其他应用"><a href="#0X04-带有小的未知乘子的隐藏数问题：MEGA-的六次查询密码分析以及其他应用" class="headerlink" title="0X04 带有小的未知乘子的隐藏数问题：MEGA 的六次查询密码分析以及其他应用"></a>0X04 带有小的未知乘子的隐藏数问题：MEGA 的六次查询密码分析以及其他应用</h1><p><a target="_blank" rel="noopener" href="https://github.com/AL3XEI709/papers/blob/main/2022-914.pdf">Link</a></p>
<blockquote>
<p>安全研究员最近提出了针对云存储提供商 MEGA 的一种攻击。该攻击通过伪装恶意服务器，在与客户端进行 512 次登录交互后会得到 RSA 私钥。这篇论文展示了由 MEGA 协议漏洞获取更多隐私的攻击攻击，只需与客户端进行 6 次登录交互即可恢复私钥。该联合攻击涉及多种密码分析技术。特别的，这篇论文还提出了一种隐藏数问题变体的解法，该变体涉及小的未知乘子。</p>
</blockquote>
<h2 id="4-1-HNP-SUM-简介"><a href="#4-1-HNP-SUM-简介" class="headerlink" title="4.1 HNP-SUM 简介"></a>4.1 HNP-SUM 简介</h2><p>论文的一项创新工作是解决了带有小的未知乘子的隐藏数问题 (以下简称为 HNP-SUM) 。</p>
<p><strong>定义1.</strong> (HNP-SUM) 对于给定的整数 $N, a_i,T,E$ ，存在整数 $x,t_i,e_i$ 满足<br>$$<br>a_i\equiv t_ix+e_i\pmod N \<br>|t_i|&lt;T\<br>|e_i|&lt;E<br>$$<br>如何恢复 $t_i$ 签名的值 (ti 互素)。</p>
<p><strong>定理1.</strong> 对 HNP-SUM 出现的 $N,a_i,T,E$ 以及随机生成的 $t_i$ ，当<br>$$<br>T^{(n+1)&#x2F;(n-1)}E&lt;N<br>$$<br>时，存在算法使HNP-SUM 可在多项式内求解。</p>
<h2 id="4-2-HNP-SUM-在对-MEGA-密码分析的应用"><a href="#4-2-HNP-SUM-在对-MEGA-密码分析的应用" class="headerlink" title="4.2 HNP-SUM 在对 MEGA 密码分析的应用"></a>4.2 HNP-SUM 在对 MEGA 密码分析的应用</h2><p>MEGA 工作 (以及实施对 MEGA 攻击) 的环境中，服务器持有客户端 RSA 私钥的密文副本，加密方式是 AES-ECB mode，密钥由用户密码派生生成。</p>
<p>在 MEGA 的登录协议中，服务器向客户端发送了一个使用 AES-ECB mode 加密的 RSA 私钥。 客户端解密 RSA 私钥，使用此 RSA 私钥解密session ID 得到 RSA 公钥 ，并发送给服务器一个应答值。RSA 私钥包含 $p,q,d,u\equiv q^{-1}\pmod p$ 。</p>
<p>客户端返回服务器的值是<br>$$<br>MSB((u(m_p-m_q)q+m_q)\mod N)<br>$$<br>$m_p\equiv c^d\mod p,m_q\equiv c^d\pmod q$ 。</p>
<p>攻击者作为恶意服务器，客户端作为解密 oracle，实质上构成了一个 HNP-SUM 问题。</p>
<h2 id="4-3-求解-HNP-SUM"><a href="#4-3-求解-HNP-SUM" class="headerlink" title="4.3 求解 HNP-SUM"></a>4.3 求解 HNP-SUM</h2>
            </div>
        </div>
    </div>
</main>

<script src="https://utteranc.es/client.js"
    repo="AL3XEI709/AL3XEI709.github.io.git"
    issue-term="pathname"
    theme="github-light"
    crossorigin="anonymous"
    async>
</script>


    <script>
    MathJax = {
        tex: {
            inlineMath: [['$', '$'], ['\\(', '\\)']]
        }
    };
</script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.min.js"></script>
  

</div>
        <div class="footer-wrapper"><footer>
    <div class="footer-container">
        <div class="footer-meta">
            
                <div class="footer-meta-copyright">
                    &copy; 2024 Al3XEI709.
                </div>
            
            
                <div class="footer-meta-licenese">
                    Licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC-BY-NC-SA 4.0</a>
                </div>
            
            
                <div class="footer-meta-rss">
                    <a href="/atom.xml"><i class="fa-solid fa-rss"></i></a>
                </div>
            
        </div>
    </div>
</footer>
</div>
    </div>
</body>
</html>
